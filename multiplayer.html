<!DOCTYPE html>
<html lang="pt-pt">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>Residencial Cana√£ - MULTIPLAYER ONLINE</title>
    <style>
        :root {
            --ui-primary: #fcee0a;
            --ui-armor: #00d4ff;
            --ui-danger: #ff003c;
            --ui-bg: #050505;
            --ui-cyan: #00f3ff;
            --ui-magenta: #ff003c;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--ui-bg);
            font-family: 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
            background: #87CEEB;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CYBERPUNK START SCREEN */
        .overlay-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }

        .overlay-screen::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 2;
        }

        .cyber-title {
            font-size: clamp(1.5rem, 6vw, 4rem);
            color: var(--ui-primary);
            font-weight: 900;
            letter-spacing: 5px;
            margin: 0 0 30px 0;
            text-transform: uppercase;
            position: relative;
            text-shadow: 3px 3px 0px var(--ui-magenta);
        }

        .cyber-title::after {
            content: "MULTIPLAYER ONLINE";
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            letter-spacing: 10px;
            color: var(--ui-cyan);
            width: 100%;
        }

        .config-box {
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border: 2px solid var(--ui-cyan);
            clip-path: polygon(0% 0%, 95% 0%, 100% 5%, 100% 100%, 5% 100%, 0% 95%);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            width: 90%;
            max-width: 650px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            position: relative;
            backdrop-filter: blur(10px);
            z-index: 5;
        }

        .config-box::before {
            content: "SYSTEM READY";
            position: absolute;
            top: 5px;
            right: 20px;
            font-size: 0.6rem;
            color: var(--ui-cyan);
        }

        .field {
            display: flex;
            flex-direction: column;
            text-align: left;
        }

        .field label {
            font-size: 0.65rem;
            font-weight: bold;
            color: var(--ui-cyan);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .field input,
        .field select {
            padding: 12px;
            border-radius: 0;
            border: none;
            background: #111;
            color: white;
            font-size: 0.9rem;
            border-left: 3px solid var(--ui-magenta);
            outline: none;
            transition: 0.3s;
        }

        .field input:focus {
            background: #222;
            border-left-color: var(--ui-primary);
        }

        input[type="range"] {
            appearance: none;
            height: 4px;
            background: #333;
            margin: 15px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--ui-primary);
            cursor: pointer;
            border-radius: 0;
        }

        .btn-main {
            grid-column: span 2;
            padding: 18px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            font-size: 1.1rem;
            text-transform: uppercase;
            font-weight: 900;
            letter-spacing: 2px;
            clip-path: polygon(5% 0%, 100% 0%, 95% 100%, 0% 100%);
        }

        .btn-play {
            background: var(--ui-primary);
            color: #000;
            margin-top: 10px;
        }

        .btn-play:hover {
            background: #fff;
            transform: scale(1.02);
            box-shadow: 0 0 20px var(--ui-primary);
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--ui-magenta);
            color: var(--ui-magenta);
            font-size: 0.8rem;
            padding: 10px;
        }

        .btn-secondary:hover {
            background: var(--ui-magenta);
            color: white;
        }

        .dev-info {
            grid-column: span 2;
            margin-top: 15px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .dev-info a {
            color: var(--ui-cyan);
            text-decoration: none;
            font-weight: bold;
            transition: 0.3s;
        }

        .dev-info a:hover {
            color: var(--ui-primary);
            text-shadow: 0 0 10px var(--ui-primary);
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .overlay-screen {
                justify-content: flex-start;
                padding: 10px;
            }

            .cyber-title {
                font-size: 1.5rem;
                margin-bottom: 20px;
                letter-spacing: 2px;
            }

            .cyber-title::after {
                font-size: 0.5rem;
                letter-spacing: 4px;
                bottom: -10px;
            }

            .config-box {
                padding: 15px;
                gap: 10px;
                max-width: 95%;
            }

            .field label {
                font-size: 0.55rem;
                margin-bottom: 4px;
            }

            .field input,
            .field select {
                padding: 8px;
                font-size: 0.8rem;
            }

            input[type="range"] {
                margin: 8px 0;
            }

            .btn-main {
                padding: 12px;
                font-size: 0.9rem;
                margin-top: 5px;
            }

            .btn-secondary {
                padding: 6px;
                font-size: 0.7rem;
            }

            .dev-info {
                margin-top: 5px;
                font-size: 0.6rem;
            }
        }

        #hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .hud-el {
            position: absolute;
            background: rgba(0, 0, 0, 0.3);
            border: 2.5px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            backdrop-filter: blur(8px);
            pointer-events: auto;
            touch-action: none;
            box-sizing: border-box;
            text-align: center;
        }

        .hud-el.dragging {
            border: 3px dashed var(--ui-primary) !important;
            background: rgba(255, 234, 0, 0.4) !important;
            z-index: 5000 !important;
            transform: scale(1.1);
        }

        #minimap-container {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            pointer-events: auto;
            z-index: 110;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* DOIS BOT√ïES DE TIRO */
        #btn-fire-ads {
            bottom: 40px;
            right: 40px;
            width: 125px;
            height: 125px;
            border-color: var(--ui-danger);
            font-size: 20px;
            background: radial-gradient(circle, rgba(255, 68, 68, 0.3) 0%, rgba(0, 0, 0, 0.2) 70%);
        }

        #btn-fire-hip {
            bottom: 40px;
            right: 180px;
            width: 90px;
            height: 90px;
            border-color: #fff;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
        }

        #btn-ads {
            bottom: 180px;
            right: 55px;
            width: 85px;
            height: 85px;
            font-size: 26px;
        }

        #btn-jump {
            bottom: 140px;
            right: 160px;
            width: 80px;
            height: 80px;
        }

        #btn-run {
            bottom: 40px;
            left: 180px;
            width: 70px;
            height: 70px;
            border-color: var(--ui-primary);
        }

        #btn-run.active {
            background: var(--ui-primary);
            color: #000;
        }

        #btn-nade {
            bottom: 125px;
            left: 180px;
            width: 70px;
            height: 70px;
        }

        #btn-swap-nade {
            bottom: 210px;
            left: 180px;
            width: 75px;
            height: 75px;
            font-size: 9px;
            border-color: var(--ui-armor);
        }

        #btn-switch-weapon {
            bottom: 300px;
            left: 180px;
            width: 75px;
            height: 75px;
            font-size: 9px;
            border-color: #fff;
        }

        #btn-settings {
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        #btn-eye {
            top: 15px;
            right: 80px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        #btn-fullscreen {
            top: 80px;
            right: 15px;
            width: 50px;
            height: 50px;
            font-size: 16px;
        }

        #joy-zone {
            bottom: 40px;
            left: 40px;
            width: 130px;
            height: 130px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
        }

        #joy-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
        }

        #status-wrap {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .bar-outer {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #f00, #0f0);
            transition: 0.3s;
        }

        #armor-bar {
            width: 100%;
            height: 100%;
            background: var(--ui-armor);
            transition: 0.3s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
        }

        #crosshair-dot {
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff0000, 0 0 2px #fff;
        }

        #hitmarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 101;
        }

        .hm-line {
            position: absolute;
            background: #fff;
            width: 2px;
            height: 8px;
            left: 50%;
            transform: translateX(-50%);
        }

        .hm-2 {
            bottom: 0;
        }

        .hm-3 {
            left: 0;
            top: 50%;
            height: 2px;
            width: 8px;
            transform: translateY(-50%);
        }

        .hm-4 {
            right: 0;
            top: 50%;
            height: 2px;
            width: 8px;
            transform: translateY(-50%);
        }

        #timer-display {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 16px;
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid var(--ui-primary);
        }

        #player-counters {
            position: absolute;
            top: 15px;
            right: 150px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid #fff;
            pointer-events: none;
            text-align: left;
        }

        .counter-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .c-alive {
            color: #0f0;
        }

        .c-dead {
            color: #f44;
        }

        .c-kills {
            color: var(--ui-primary);
        }

        #kill-log {
            position: absolute;
            top: 70px;
            left: 15px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        .kill-entry {
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            border-left: 3px solid var(--ui-danger);
            animation: slideIn 0.3s ease-out;
        }

        #game-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--ui-primary);
            text-align: center;
            display: none;
            z-index: 3000;
        }

        #save-hud-btn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #28a745;
            color: white;
            padding: 15px 50px;
            border-radius: 12px;
            font-weight: bold;
            z-index: 6000;
            display: none;
            border: 3px solid white;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        /* NOVA MIRA SNIPER */
        #sniper-scope {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle, transparent 30%, black 70%);
            pointer-events: none;
            display: none;
            z-index: 2000;
        }

        #sniper-scope::before,
        #sniper-scope::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #00ff00;
        }

        #sniper-scope::before {
            width: 100vw;
            height: 1px;
            opacity: 0.5;
        }

        #sniper-scope::after {
            width: 1px;
            height: 100vh;
            opacity: 0.5;
        }

        #sniper-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
        }

        /* ESTILOS MULTIPLAYER */
        #lobby-screen {
            z-index: 1001;
        }

        #lobby-code-display {
            font-size: 2.5rem;
            color: var(--ui-primary);
            letter-spacing: 10px;
            font-weight: 900;
            padding: 15px 30px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid var(--ui-primary);
            margin: 20px 0;
        }

        #players-list {
            background: rgba(0, 0, 0, 0.6);
            padding: 20px;
            margin: 15px 0;
            border: 1px solid var(--ui-cyan);
            max-height: 150px;
            overflow-y: auto;
            text-align: left;
        }

        .player-item {
            padding: 8px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-left: 3px solid var(--ui-primary);
            color: var(--ui-cyan);
            font-size: 0.9rem;
        }

        #ping-display {
            position: absolute;
            top: 80px;
            right: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 5px 12px;
            border-radius: 8px;
            color: #0f0;
            font-size: 11px;
            font-weight: bold;
        }

        .nametag {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: bold;
            pointer-events: none;
            white-space: nowrap;
            border: 1px solid var(--ui-cyan);
        }

        /* ROOM CARDS */
        .room-card {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            margin: 10px 0;
            border: 1px solid var(--ui-cyan);
            border-left: 4px solid var(--ui-primary);
            transition: 0.3s;
            cursor: pointer;
        }

        .room-card:hover {
            background: rgba(0, 243, 255, 0.1);
            border-left-color: var(--ui-cyan);
            transform: translateX(5px);
        }

        .room-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .room-code {
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--ui-primary);
            letter-spacing: 2px;
        }

        .room-mode {
            background: var(--ui-cyan);
            color: #000;
            padding: 3px 10px;
            font-size: 0.7rem;
            font-weight: 900;
            border-radius: 3px;
        }

        .room-info {
            display: flex;
            gap: 20px;
            font-size: 0.75rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .room-players {
            color: var(--ui-primary);
            font-weight: bold;
        }

        /* LIVES DISPLAY */
        #lives-display {
            position: absolute;
            top: 60px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid var(--ui-danger);
            color: var(--ui-danger);
            font-size: 14px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* RESPAWN SCREEN */
        #respawn-screen {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 2500;
        }

        #respawn-screen.active {
            display: flex;
        }

        .respawn-content {
            text-align: center;
            color: white;
        }

        .respawn-timer {
            font-size: 4rem;
            color: var(--ui-primary);
            font-weight: 900;
            text-shadow: 0 0 20px var(--ui-primary);
        }

        /* TEAM INDICATOR */
        #team-indicator {
            position: absolute;
            top: 100px;
            left: 15px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            border: 2px solid;
            font-size: 12px;
            font-weight: bold;
            display: none;
        }

        /* VOICE CHAT BUTTON */
        #btn-voice {
            position: absolute;
            bottom: 220px;
            right: 55px;
            width: 70px;
            height: 70px;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.3);
            border: 2.5px solid var(--ui-cyan);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 30px;
            cursor: pointer;
            pointer-events: auto;
            touch-action: none;
            transition: 0.3s;
        }

        #btn-voice.active {
            background: var(--ui-cyan);
            color: #000;
            box-shadow: 0 0 20px var(--ui-cyan);
            transform: scale(1.1);
        }

        #btn-voice.muted {
            opacity: 0.5;
            border-color: var(--ui-danger);
        }

        /* LOADING SCREEN */
        #loading-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a1a2e 50%, #0a0a0a 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 1;
            transition: opacity 0.5s ease-out;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-content {
            text-align: center;
            color: white;
        }

        .loading-content h1 {
            font-size: 2.5rem;
            color: var(--ui-primary);
            text-shadow: 0 0 20px var(--ui-primary), 0 0 40px var(--ui-cyan);
            margin-bottom: 30px;
            letter-spacing: 4px;
            animation: pulse 2s infinite;
        }

        .progress-bar {
            width: 400px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 0 auto 20px;
            border: 1px solid var(--ui-cyan);
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.3);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--ui-cyan), var(--ui-primary));
            border-radius: 10px;
            transition: width 0.3s ease;
            box-shadow: 0 0 20px var(--ui-primary);
        }

        .loading-text {
            color: var(--ui-cyan);
            font-size: 1rem;
            letter-spacing: 2px;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }
    </style>
</head>

<body onload="loadConfigs()">

    <!-- LOADING SCREEN -->
    <div id="loading-screen" class="hidden">
        <div class="loading-content">
            <h1>CARREGANDO MAPA</h1>
            <div class="progress-bar">
                <div class="progress-fill" id="loading-progress"></div>
            </div>
            <p class="loading-text" id="loading-text">Iniciando...</p>
        </div>
    </div>

    <div id="game-container"></div>
    <div id="sniper-scope">
        <div id="sniper-center"></div>
    </div>

    <div id="game-msg">
        <h2 id="msg-title"></h2>
        <p id="msg-body"></p>
        <button class="btn-main btn-play" onclick="location.reload()">RECOME √áAR</button>
    </div>

    <button id="save-hud-btn" onclick="toggleHudEdit()">üíæ SALVAR HUD</button>

    <!-- TELA DE SELE√á√ÉO DE MODO -->
    <div id="mode-select-screen" class="overlay-screen">
        <div class="cyber-title">RESIDENCIAL CANA√É</div>
        <div class="config-box">
            <div class="field">
                <label>// SEU NOME</label>
                <input type="text" id="player-name-input" value="" placeholder="Digite seu nome" maxlength="16">
            </div>
            <div class="field">
                <label>// SENSIBILIDADE [<span id="val-sens-start">55</span>]</label>
                <input type="range" id="cfg-sens" min="1" max="100" value="55"
                    oninput="document.getElementById('val-sens-start').innerText=this.value">
            </div>
            <div class="field">
                <label>// FOV [<span id="val-fov-start">75</span>]</label>
                <input type="range" id="cfg-fov" min="40" max="100" value="75"
                    oninput="document.getElementById('val-fov-start').innerText=this.value">
            </div>
            <button class="btn-main btn-secondary" onclick="toggleHudEdit()">‚úèÔ∏è CUSTOMIZAR INTERFACE (HUD)</button>
            <button class="btn-main btn-play" onclick="showRoomOptions()">[ CRIAR SALA ]</button>
            <button class="btn-main btn-play" onclick="showRoomList()">[ VER SALAS P√öBLICAS ]</button>
            <button class="btn-main btn-secondary" onclick="showJoinRoom()">ENTRAR POR C√ìDIGO</button>

            <div class="dev-info">
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">// DEVELOPER: _nildoxz</a>
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">Cana√£ dos Caraj√°s - 2026</a>
            </div>
        </div>
    </div>

    <!-- TELA DE LISTA DE SALAS -->
    <div id="room-list-screen" class="overlay-screen hidden">
        <div class="cyber-title">SALAS P√öBLICAS</div>
        <div
            style="width: 90%; max-width: 750px; background: rgba(0,0,0,0.85); padding: 30px; border: 2px solid var(--ui-cyan); backdrop-filter: blur(10px); z-index: 5;">

            <div style="margin-bottom: 20px; display: flex; gap: 10px;">
                <button class="btn-main btn-secondary" onclick="refreshRoomList()" style="flex: 1;">üîÑ
                    ATUALIZAR</button>
                <button class="btn-main btn-secondary" onclick="showRoomOptions()" style="flex: 1;">‚ûï CRIAR
                    SALA</button>
            </div>

            <div id="rooms-container" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
                <!-- Salas ser√£o inseridas aqui dinamicamente -->
                <div style="text-align: center; color: rgba(255,255,255,0.6); padding: 40px;">
                    <p>üîç Procurando salas...</p>
                </div>
            </div>

            <button class="btn-main btn-secondary" onclick="backToModeSelect()" style="width: 100%;">VOLTAR</button>
        </div>
    </div>

    <!-- TELA DE CRIAR SALA -->
    <div id="create-room-screen" class="overlay-screen hidden">
        <div class="cyber-title">CRIAR SALA</div>
        <div class="config-box">
            <div class="field">
                <label>// MODO DE JOGO</label>
                <select id="game-mode-select">
                    <option value="solo">SOLO (Todos contra Todos)</option>
                    <option value="duo">DUO (Equipes de 2)</option>
                    <option value="squad">SQUAD (Equipes de 4)</option>
                </select>
            </div>
            <div class="field">
                <label>// VISIBILIDADE</label>
                <select id="room-visibility-select">
                    <option value="true">P√öBLICA (Vis√≠vel para todos)</option>
                    <option value="false">PRIVADA (Apenas por c√≥digo)</option>
                </select>
            </div>
            <div class="field">
                <label>// M√ÅX. JOGADORES</label>
                <input type="number" id="max-players-input" value="50" min="2" max="100">
            </div>
            <div class="field">
                <label>// N¬∫ BOTS (IA)</label>
                <input type="number" id="mp-bot-count" value="10" min="0" max="60">
            </div>
            <div class="field">
                <label>// DIFICULDADE BOTS</label>
                <select id="mp-bot-diff">
                    <option value="1">Casual</option>
                    <option value="2" selected>Normal</option>
                    <option value="3">Veterano</option>
                </select>
            </div>
            <button class="btn-main btn-play" onclick="createRoom()">[ CRIAR E AGUARDAR ]</button>
            <button class="btn-main btn-secondary" onclick="backToModeSelect()">VOLTAR</button>
        </div>
    </div>

    <!-- TELA DE ENTRAR EM SALA -->
    <div id="join-room-screen" class="overlay-screen hidden">
        <div class="cyber-title">ENTRAR EM SALA</div>
        <div class="config-box">
            <div class="field">
                <label>// C√ìDIGO DA SALA</label>
                <input type="text" id="room-code-input" value="" placeholder="EX: ABC123" maxlength="6"
                    style="text-transform: uppercase;">
            </div>
            <button class="btn-main btn-play" onclick="joinRoom()">[ ENTRAR NA PARTIDA ]</button>
            <button class="btn-main btn-secondary" onclick="backToModeSelect()">VOLTAR</button>
        </div>
    </div>

    <!-- TELA DE LOBBY (AGUARDANDO JOGADORES) -->
    <div id="lobby-screen" class="overlay-screen hidden">
        <div class="cyber-title">LOBBY</div>
        <div
            style="width: 90%; max-width: 650px; background: rgba(0,0,0,0.85); padding: 30px; border: 2px solid var(--ui-cyan); backdrop-filter: blur(10px); z-index: 5;">
            <div style="text-align: center; margin-bottom: 20px;">
                <div style="color: var(--ui-cyan); font-size: 0.9rem; margin-bottom: 10px;">// C√ìDIGO DA SALA</div>
                <div id="lobby-code-display">------</div>
                <div style="color: rgba(255,255,255,0.6); font-size: 0.75rem; margin-top: 10px;">Compartilhe este c√≥digo
                    com seus amigos</div>
            </div>

            <div style="color: var(--ui-cyan); font-size: 0.9rem; margin-bottom: 10px; text-align: center;">// JOGADORES
                CONECTADOS (<span id="lobby-player-count">0</span>)</div>
            <div id="players-list"></div>

            <button class="btn-main btn-play" onclick="startMultiplayerGame()" style="width: 100%; margin-top: 20px;">[
                INICIAR JOGO ]</button>
            <button class="btn-main btn-secondary" onclick="location.reload()"
                style="width: 100%; margin-top: 10px;">SAIR DA SALA</button>
        </div>
    </div>

    <div id="start-screen" class="overlay-screen hidden">
        <div class="cyber-title">RESIDENCIAL CANA√É</div>
        <div class="config-box">
            <div class="field">
                <label>// N¬∫ SOLDADOS</label>
                <input type="number" id="bot-count" value="20" min="1" max="60">
            </div>
            <div class="field">
                <label>// DIFICULDADE</label>
                <select id="bot-diff">
                    <option value="1">Casual</option>
                    <option value="2" selected>Normal</option>
                    <option value="3">Veterano</option>
                </select>
            </div>
            <div class="field">
                <label>// SENSIBILIDADE [<span id="val-sens-start2">55</span>]</label>
                <input type="range" id="cfg-sens2" min="1" max="100" value="55"
                    oninput="document.getElementById('val-sens-start2').innerText=this.value">
            </div>
            <div class="field">
                <label>// FOV [<span id="val-fov-start2">75</span>]</label>
                <input type="range" id="cfg-fov2" min="40" max="100" value="75"
                    oninput="document.getElementById('val-fov-start2').innerText=this.value">
            </div>
            <button class="btn-main btn-secondary" onclick="toggleHudEdit()">‚úèÔ∏è CUSTOMIZAR INTERFACE (HUD)</button>
            <button class="btn-main btn-play" onclick="initGame()">[ INICIAR PROTOCOLO ]</button>

            <div class="dev-info">
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">// DEVELOPER: _nildoxz</a>
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">Cana√£ dos Caraj√°s - 2026</a>
            </div>
        </div>
    </div>

    <div id="pause-menu" class="overlay-screen hidden">
        <div class="cyber-title">PAUSA</div>
        <div class="config-box">
            <div class="field"><label>// SENSIBILIDADE</label><input type="range" id="menu-sens" min="1" max="100"
                    value="55" oninput="updateLiveSettings('sens', this.value)"></div>
            <div class="field"><label>// FOV</label><input type="range" id="menu-fov" min="40" max="100" value="75"
                    oninput="updateLiveSettings('fov', this.value)"></div>
            <button class="btn-main btn-secondary" onclick="toggleHudEdit()">‚úèÔ∏è REPOSICIONAR BOT√ïES</button>
            <button class="btn-main btn-play" onclick="togglePauseMenu()">CONTINUAR OPERA√á√ÉO</button>
            <button class="btn-main" style="background: var(--ui-danger); color: #fff; margin-top: 10px;"
                onclick="location.reload()">ABORTAR</button>

            <div class="dev-info">
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">// DEVELOPER: _nildoxz</a>
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">Cana√£ dos Caraj√°s - 2026</a>
            </div>
        </div>
    </div>

    <div id="hud">
        <div id="timer-display">ZONA: 100s</div>
        <div id="ping-display">PING: <span id="ping-value">0</span>ms</div>

        <!-- NOVO: Contador de Vidas -->
        <div id="lives-display" style="display: none;">
            ‚ù§Ô∏è <span id="lives-count">5</span>
        </div>

        <!-- NOVO: Indicador de Equipe -->
        <div id="team-indicator">
            EQUIPE <span id="team-name">1</span>
        </div>

        <div id="player-counters">
            <div class="counter-row"><span>VIVOS:</span> <span id="count-alive" class="c-alive">0</span></div>
            <div class="counter-row"><span>MORTOS:</span> <span id="count-dead" class="c-dead">0</span></div>
            <div class="counter-row"><span>ABATES:</span> <span id="count-kills" class="c-kills">0</span></div>
        </div>

        <div id="kill-log"></div>
        <div id="crosshair">
            <div id="crosshair-dot"></div>
        </div>
        <div id="hitmarker">
            <div class="hm-line hm-1"></div>
            <div class="hm-line hm-2"></div>
            <div class="hm-line hm-3"></div>
            <div class="hm-line hm-4"></div>
        </div>

        <div id="status-wrap">
            <div class="bar-outer">
                <div id="armor-bar"></div>
            </div>
            <div class="bar-outer">
                <div id="hp-bar"></div>
            </div>
        </div>

        <div id="btn-settings" class="hud-el">‚öôÔ∏è</div>
        <div id="btn-eye" class="hud-el">üëÅÔ∏è</div>
        <div id="btn-fire-ads" class="hud-el">TIRO<br>ADS</div>
        <div id="btn-fire-hip" class="hud-el">TIRO<br>HIP</div>
        <div id="btn-ads" class="hud-el">üéØ</div>
        <div id="btn-jump" class="hud-el">PULAR</div>
        <div id="btn-run" class="hud-el">üèÉ</div>
        <div id="btn-nade" class="hud-el">üí£</div>
        <div id="btn-swap-nade" class="hud-el">BOMBA<br>(EXPL)</div>
        <div id="btn-switch-weapon" class="hud-el">ARMA<br>(FUZIL)</div>
        <div id="btn-fullscreen" class="hud-el" onclick="toggleFullscreen()">‚õ∂</div>

        <!-- NOVO: Bot√£o Voice Chat -->
        <div id="btn-voice" class="hud-el" title="Pressione para falar">üé§</div>

        <div id="joy-zone" class="hud-el">
            <div id="joy-knob"></div>
        </div>
        <div id="minimap-container" class="hud-el"><canvas id="minimap-canvas"></canvas></div>
    </div>

    <!-- NOVO: Tela de Respawn -->
    <div id="respawn-screen">
        <div class="respawn-content">
            <h2 style="color: var(--ui-danger); font-size: 2rem; margin-bottom: 20px;">ELIMINADO</h2>
            <div class="respawn-timer" id="respawn-timer">5</div>
            <p style="font-size: 1.2rem; margin-top: 20px;">Respawn em...</p>
            <p style="color: var(--ui-primary); font-size: 0.9rem;">Vidas restantes: <span id="respawn-lives">4</span>
            </p>
        </div>
    </div>

    <!-- Socket.io CDN -->
    <script src="/socket.io/socket.io.js"></script>

    <!-- Voice Chat Module -->
    <script src="voice-chat.js"></script>

    <script
        type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, clock, playerGroup, charModel, zoneMesh, sunObj;
        let cameraYaw = 0, cameraPitch = 0, vY = 0, jumps = 0;
        let isPlaying = false, isPaused = false, isRunning = false, isADS = false, isShooting = false, isFPS = false;
        let fireFocusTimer = 0;
        let currentWeapon = 'AR', grenadeType = 'explosive';
        let bullets = [], bots = [], obstacles = [], obstacleBoxes = [], grenades = [], effects = [], medkits = [];
        let health = 100, armor = 100, lastShot = 0, lastDamageTime = 0, playerKills = 0;
        let zoneTimer = 100, zoneRadius = 500, zoneActive = false;
        let initialBotCount = 20, houseData = [];
        let gasPauseCount = 0, gasPauseTimer = 0;
        let isHost = false; // HOST AUTHORITY FOR BOTS
        let lastBotUpdate = 0;

        const ray = new THREE.Raycaster();
        const keys = {};

        let minimapCtx, minimapCanvas;
        let moveVec = new THREE.Vector2(), moveTouchId = null, lookTouchId = null, fireTouchId = null;
        let lastX = 0, lastY = 0, fireLastX = 0, fireLastY = 0;
        let isEditingHud = false, cfg = { bots: 20, diff: 2, sens: 0.0165, fov: 75 };

        // ============================================
        // VARI√ÅVEIS MULTIPLAYER
        // ============================================
        let socket = null;
        let isMultiplayer = false;
        let myPlayerId = null;
        let currentRoomCode = null;
        let remotePlayers = new Map();
        let lastPingTime = 0;
        let positionUpdateInterval = null;

        // NOVO: Sistema de Vidas e Equipes
        let playerLives = 5;
        let isRespawning = false;
        let respawnTimer = 0;
        let myTeamId = null;
        let gameMode = 'solo'; // 'solo', 'duo', 'squad'
        let teamColors = {
            0: '#00ff00', // Verde
            1: '#00d4ff', // Azul
            2: '#fcee0a', // Amarelo
            3: '#ff003c'  // Vermelho
        };

        // NOVO: Voice Chat
        let voiceChat = null;
        let isPushToTalkActive = false;

        // ============================================
        // CARREGAR CONFIGURA√á√ïES
        // ============================================
        window.loadConfigs = function () {
            // Primeiro, verifica par√¢metros da URL
            const urlParams = new URLSearchParams(window.location.search);

            // Aplicar configura√ß√µes da URL ou localStorage
            const sens = urlParams.get('sens') || localStorage.getItem('sens') || '55';
            const fov = urlParams.get('fov') || localStorage.getItem('fov') || '75';
            const playerName = urlParams.get('playerName') || localStorage.getItem('playerName') || '';
            const botCount = urlParams.get('botCount') || localStorage.getItem('botCountMP') || '10';
            const botDiff = urlParams.get('botDiff') || localStorage.getItem('botDiff') || '2';

            document.getElementById('cfg-sens').value = sens;
            document.getElementById('cfg-fov').value = fov;
            document.getElementById('val-sens-start').innerText = sens;
            document.getElementById('val-fov-start').innerText = fov;
            document.getElementById('player-name-input').value = playerName;

            // Aplicar configura√ß√µes de bots se existirem na tela
            const botCountInput = document.getElementById('mp-bot-count');
            const botDiffInput = document.getElementById('mp-bot-diff');
            if (botCountInput) botCountInput.value = botCount;
            if (botDiffInput) botDiffInput.value = botDiff;

            // Salvar no localStorage
            localStorage.setItem('playerName', playerName);
        };

        // Salvar configura√ß√µes gerais (sensibilidade, fov)
        window.saveGeneralConfigs = function () {
            const gc = {
                sens: document.getElementById('cfg-sens').value,
                fov: document.getElementById('cfg-fov').value
            };
            localStorage.setItem('canaa_config_v1', JSON.stringify(gc));
        };

        // ============================================
        // FUN√á√ïES DE NAVEGA√á√ÉO MULTIPLAYER
        // ============================================
        window.toggleHudEdit = function () {
            isEditingHud = !isEditingHud;
            const elements = document.querySelectorAll('.hud-el');
            elements.forEach(el => {
                if (isEditingHud) {
                    el.style.opacity = '0.7';
                    el.style.border = '2px dashed var(--ui-cyan)';
                } else {
                    el.style.opacity = '1';
                    el.style.border = 'none';
                }
            });
            const btn = document.getElementById('save-hud-btn');
            if (btn) btn.style.display = isEditingHud ? 'block' : 'none';
        };

        window.showRoomOptions = function () {
            console.log('[NAV] Abrindo tela de criar sala...');
            document.getElementById('mode-select-screen').classList.add('hidden');
            document.getElementById('create-room-screen').classList.remove('hidden');
        };

        window.showJoinRoom = function () {
            console.log('[NAV] Abrindo tela de entrar por c√≥digo...');
            document.getElementById('mode-select-screen').classList.add('hidden');
            document.getElementById('join-room-screen').classList.remove('hidden');
        };

        window.backToModeSelect = function () {
            console.log('[NAV] Voltando para sele√ß√£o de modo...');
            document.getElementById('create-room-screen').classList.add('hidden');
            document.getElementById('join-room-screen').classList.add('hidden');
            document.getElementById('room-list-screen').classList.add('hidden');
            document.getElementById('mode-select-screen').classList.remove('hidden');
        };

        // NOVO: Mostrar lista de salas p√∫blicas
        window.showRoomList = function () {
            console.log('[NAV] Abrindo lista de salas p√∫blicas...');
            document.getElementById('mode-select-screen').classList.add('hidden');
            document.getElementById('room-list-screen').classList.remove('hidden');
            refreshRoomList();
        };

        // NOVO: Atualizar lista de salas
        window.refreshRoomList = function () {
            if (!socket) {
                socket = io();
            }

            socket.emit('list-rooms');

            socket.once('rooms-list', (rooms) => {
                const container = document.getElementById('rooms-container');

                if (rooms.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: rgba(255,255,255,0.6); padding: 40px;">
                            <p>üòï Nenhuma sala p√∫blica dispon√≠vel</p>
                            <p style="font-size: 0.8rem;">Crie uma nova sala ou entre por c√≥digo</p>
                        </div>
                    `;
                    return;
                }

                container.innerHTML = rooms.map(room => `
                    <div class="room-card" onclick="joinRoomByCode('${room.code}')">
                        <div class="room-card-header">
                            <div class="room-code">${room.code}</div>
                            <div class="room-mode">${room.gameMode.toUpperCase()}</div>
                        </div>
                        <div class="room-info">
                            <span>Host: ${room.hostName}</span>
                            <span class="room-players">üë• ${room.playerCount}/${room.maxPlayers}</span>
                            <span>${room.gameStarted ? 'üî¥ Em Jogo' : 'üü¢ Aguardando'}</span>
                        </div>
                    </div>
                `).join('');
            });
        };

        // NOVO: Entrar em sala diretamente pelo c√≥digo
        window.joinRoomByCode = function (code) {
            document.getElementById('room-code-input').value = code;
            document.getElementById('room-list-screen').classList.add('hidden');
            document.getElementById('join-room-screen').classList.remove('hidden');
        };

        // NOVO: Atualizar display de equipe
        function updateTeamDisplay() {
            const teamIndicator = document.getElementById('team-indicator');
            if (gameMode !== 'solo' && myTeamId !== null) {
                const teamIndex = Array.from(new Set(
                    Array.from(remotePlayers.values())
                        .map(p => p.state?.teamId)
                        .filter(t => t)
                )).indexOf(myTeamId);

                const teamColor = teamColors[teamIndex] || teamColors[0];

                teamIndicator.style.borderColor = teamColor;
                teamIndicator.style.color = teamColor;
                teamIndicator.style.display = 'block';
                document.getElementById('team-name').innerText = teamIndex + 1;
            } else {
                teamIndicator.style.display = 'none';
            }
        }

        // NOVO: Lidar com morte do jogador
        function handlePlayerDeath(data) {
            playerLives = data.livesRemaining;
            document.getElementById('lives-count').innerText = playerLives;

            if (playerLives > 0) {
                isRespawning = true;
                respawnTimer = data.respawnTime || 5;
                showRespawnScreen();
            } else {
                showMsg('ELIMINADO', 'Voc√™ foi eliminado da partida!');
            }
        }

        // NOVO: Mostrar tela de respawn
        function showRespawnScreen() {
            const respawnScreen = document.getElementById('respawn-screen');
            respawnScreen.classList.add('active');
            document.getElementById('respawn-lives').innerText = playerLives;

            const timerInterval = setInterval(() => {
                respawnTimer--;
                document.getElementById('respawn-timer').innerText = respawnTimer;

                if (respawnTimer <= 0) {
                    clearInterval(timerInterval);
                    respawnScreen.classList.remove('active');
                    isRespawning = false;
                }
            }, 1000);
        }

        let uiCache = {};

        function initUICache() {
            uiCache = {
                ammo: document.getElementById('ammo-display'),
                health: document.getElementById('hp-bar'),
                armor: document.getElementById('armor-bar'),
                alive: document.getElementById('count-alive'),
                dead: document.getElementById('count-dead'),
                kills: document.getElementById('count-kills'),
                timer: document.getElementById('timer-display'),
                lives: document.getElementById('lives-count'),
                stamina: document.getElementById('stamina-bar'), // Se existir
                sniperScope: document.getElementById('sniper-scope')
            };
        }

        // Criar sala multiplayer
        window.createRoom = function () {
            const playerName = document.getElementById('player-name-input').value.trim() || `Jogador${Math.floor(Math.random() * 1000)}`;
            const maxPlayers = parseInt(document.getElementById('max-players-input').value) || 50;
            const botCount = parseInt(document.getElementById('mp-bot-count').value) || 0;
            const botDiff = parseInt(document.getElementById('mp-bot-diff').value) || 2;
            const selectedGameMode = document.getElementById('game-mode-select').value;
            const isPublic = document.getElementById('room-visibility-select').value === 'true';

            // Configurar quantidade e dificuldade dos bots
            initialBotCount = botCount;
            cfg.bots = botCount;
            cfg.diff = botDiff;
            gameMode = selectedGameMode; // Salvar modo de jogo

            socket = io();
            isMultiplayer = true;

            socket.emit('create-room', {
                playerName,
                maxPlayers,
                isPublic,
                gameMode: selectedGameMode,
                botCount,
                botDifficulty: botDiff
            });

            socket.on('room-created', (data) => {
                initUICache(); // Inicializar cache de UI
                myPlayerId = data.playerId;
                currentRoomCode = data.roomCode;
                myTeamId = data.playerState.teamId; // Salvar ID da equipe
                isHost = true; // Sou o host

                document.getElementById('lobby-code-display').innerText = currentRoomCode;
                document.getElementById('create-room-screen').classList.add('hidden');
                document.getElementById('lobby-screen').classList.remove('hidden');

                updatePlayersList([{ id: data.playerId, name: playerName }]);
                setupMultiplayerListeners();
            });

            socket.on('error', (data) => alert(data.message));
        };

        // Entrar em sala
        window.joinRoom = function () {
            const playerName = document.getElementById('player-name-input').value.trim() || `Jogador${Math.floor(Math.random() * 1000)}`;
            const roomCode = document.getElementById('room-code-input').value.trim().toUpperCase();

            if (!roomCode || roomCode.length !== 6) {
                alert('Digite um c√≥digo v√°lido (6 caracteres)');
                return;
            }

            socket = io();
            isMultiplayer = true;

            socket.emit('join-room', { roomCode, playerName });

            socket.on('room-joined', (data) => {
                initUICache(); // Inicializar cache de UI
                myPlayerId = data.playerId;
                currentRoomCode = data.roomCode;
                isHost = false; // N√£o sou o host

                document.getElementById('lobby-code-display').innerText = currentRoomCode;
                document.getElementById('join-room-screen').classList.add('hidden');

                // Se o jogo j√° estiver rolando (Late Join), entra direto
                if (data.roomInfo.gameStarted) {
                    document.getElementById('start-screen').style.display = 'none'; // Setup Inputs usa start-screen
                    document.getElementById('lobby-screen').classList.add('hidden');

                    // Simular inicio de jogo localmente
                    handleGameStarted({
                        players: data.allPlayers,
                        gameMode: data.roomInfo.gameMode,
                        botCount: data.roomInfo.botCount || 0,
                        teams: {} // Teams ser√£o atualizados via players-state ou room-joined
                    });
                } else {
                    document.getElementById('lobby-screen').classList.remove('hidden');
                }

                const players = Object.values(data.allPlayers).map(p => ({ id: p.id, name: p.name }));
                updatePlayersList(players);
                setupMultiplayerListeners();
            });

            socket.on('error', (data) => alert(data.message));
        };

        // Iniciar jogo multiplayer
        window.startMultiplayerGame = function () {
            if (socket) socket.emit('start-game');
        };

        // Atualizar lista de jogadores
        function updatePlayersList(players) {
            const list = document.getElementById('players-list');
            const count = document.getElementById('lobby-player-count');

            count.innerText = players.length;
            list.innerHTML = '';

            players.forEach(p => {
                const item = document.createElement('div');
                item.className = 'player-item';
                item.innerText = `üéÆ ${p.name}`;
                list.appendChild(item);
            });
        }

        // Configurar listeners multiplayer
        function setupMultiplayerListeners() {
            // NOVO: Sincroniza√ß√£o de bots (Host Authority)
            socket.on('bots-update', (botsData) => {
                if (!isHost) {
                    botsData.forEach((botState, index) => {
                        if (index < bots.length) {
                            const bot = bots[index];
                            if (botState.health > 0) {
                                bot.position.set(botState.pos.x, botState.pos.y, botState.pos.z);
                                if (botState.rot) bot.rotation.y = botState.rot;
                                bot.userData.health = botState.health;
                            } else {
                                // Bot morreu, esconder/desativar
                                bot.position.y = -1000;
                                bot.userData.health = 0;
                            }
                        }
                    });
                }
            });

            socket.on('player-joined', (data) => {
                const currentPlayers = Array.from(document.querySelectorAll('.player-item')).map(el => el.innerText.replace('üéÆ ', ''));
                currentPlayers.push(data.playerState.name);
                updatePlayersList(currentPlayers.map((name, i) => ({ id: i, name })));
            });

            socket.on('player-left', (data) => {
                if (remotePlayers.has(data.playerId)) {
                    const playerData = remotePlayers.get(data.playerId);
                    scene.remove(playerData.model);
                    if (playerData.nametag) playerData.nametag.remove();
                    remotePlayers.delete(data.playerId);
                }
            });

            socket.on('game-started', (data) => {
                handleGameStarted(data);
            });

            function handleGameStarted(data) {
                document.getElementById('lobby-screen').classList.add('hidden');
                document.getElementById('game-container').style.display = 'block';
                document.getElementById('hud').style.display = 'block';

                cfg.sens = parseInt(document.getElementById('cfg-sens').value) * 0.0003;
                cfg.fov = parseInt(document.getElementById('cfg-fov').value);

                // NOVO: Configurar bots do servidor
                initialBotCount = data.botCount || 0;
                cfg.bots = initialBotCount;
                cfg.diff = data.botDifficulty || 2;

                // NOVO: Configurar modo de jogo e equipe
                gameMode = data.gameMode || 'solo';
                if (data.players[myPlayerId]) {
                    myTeamId = data.players[myPlayerId].teamId;
                    playerLives = data.players[myPlayerId].lives || 5;
                }

                // NOVO: Inicializar Voice Chat
                if (window.VoiceChat && !voiceChat) {
                    voiceChat = new VoiceChat(socket, myPlayerId);
                    voiceChat.initialize().then(success => {
                        if (success) {
                            console.log('[VOICE CHAT] Inicializado');
                            setupVoiceChatUI();
                        }
                    });
                }

                // NOVO: Configurar inputs do PC
                setupInputs();

                setupThree();
                setupMinimap();
                isPlaying = true;
                startZoneTimer();

                // Criar jogadores remotos
                Object.values(data.players).forEach(playerState => {
                    if (playerState.id !== myPlayerId) {
                        createRemotePlayer(playerState);
                    }
                });

                // NOVO: Atualizar HUD com vidas e equipe
                document.getElementById('lives-display').style.display = 'flex';
                document.getElementById('lives-count').innerText = playerLives;
                updateTeamDisplay();

                // Iniciar envio de posi√ß√£o
                positionUpdateInterval = setInterval(() => {
                    if (isMultiplayer && socket && playerGroup) {
                        socket.emit('player-move', {
                            position: { x: playerGroup.position.x, y: playerGroup.position.y, z: playerGroup.position.z },
                            rotation: { yaw: cameraYaw, pitch: cameraPitch }
                        });
                    }
                }, 50); // 20 vezes por segundo
            }

            // NOVO: Relay de bots do servidor
            socket.on('bots-update', (botsData) => {
                if (!isHost) {
                    botsData.forEach((botState, index) => {
                        if (index < bots.length) {
                            const bot = bots[index];
                            bot.position.set(botState.pos.x, botState.pos.y, botState.pos.z);
                            bot.rotation.y = botState.rot || 0;
                            bot.userData.hp = botState.health;
                        }
                    });
                }
            });

            socket.on('player-moved', (data) => {
                if (remotePlayers.has(data.playerId)) {
                    const remotePlayer = remotePlayers.get(data.playerId);
                    remotePlayer.state.position = data.position;
                    remotePlayer.state.rotation = data.rotation;
                }
            });

            socket.on('players-state', (playersState) => {
                Object.entries(playersState).forEach(([playerId, state]) => {
                    if (playerId !== myPlayerId && remotePlayers.has(playerId)) {
                        remotePlayers.get(playerId).state = state;
                    }
                });
            });

            socket.on('bullet-fired', (data) => {
                if (data.shooterId !== myPlayerId) {
                    const from = new THREE.Vector3(data.from.x, data.from.y, data.from.z);
                    const to = new THREE.Vector3(data.to.x, data.to.y, data.to.z);
                    spawnBullet('remote', from, to, data.shooterId);
                }
            });

            socket.on('player-eliminated', (data) => {
                addKillLog(`${data.killerName} ‚öîÔ∏è ${data.victimName}`);

                if (data.victimId === myPlayerId) {
                    showMsg("ELIMINADO", `Voc√™ foi eliminado por ${data.killerName}`);
                }

                if (remotePlayers.has(data.victimId)) {
                    const playerData = remotePlayers.get(data.victimId);
                    scene.remove(playerData.model);
                    if (playerData.nametag) playerData.nametag.remove();
                    remotePlayers.delete(data.victimId);
                }
            });

            socket.on('player-damaged', (data) => {
                if (data.playerId === myPlayerId) {
                    health = data.health;
                    armor = data.armor;
                    triggerHitmarker();
                }
            });

            socket.on('zone-update', (data) => {
                zoneRadius = data.radius;
                if (zoneMesh) zoneMesh.scale.set(zoneRadius, 1, zoneRadius);
            });

            socket.on('grenade-thrown', (data) => {
                if (data.playerId !== myPlayerId) {
                    const g = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), new THREE.MeshStandardMaterial({ color: data.type === 'explosive' ? 0x222222 : 0xeeeeee }));
                    g.position.set(data.position.x, data.position.y, data.position.z);
                    g.userData = { vel: new THREE.Vector3(data.velocity.x, data.velocity.y, data.velocity.z), life: 120, type: data.type, hasStopped: false };
                    scene.add(g);
                    grenades.push(g);
                }
            });

            // NOVO: Jogador morreu (mas vai respawnar)
            socket.on('player-died', (data) => {
                if (data.victimId === myPlayerId) {
                    handlePlayerDeath(data);
                }
                addKillLog(`${data.killerName} ‚öîÔ∏è ${data.victimName} (${data.livesRemaining} ‚ù§Ô∏è)`);
            });

            // NOVO: Atualizar lista de salas
            socket.on('room-list-updated', () => {
                const roomListScreen = document.getElementById('room-list-screen');
                if (roomListScreen && !roomListScreen.classList.contains('hidden')) {
                    refreshRoomList();
                }
            });

            // NOVO: Atualizar estados dos jogadores (incluindo vidas)
            socket.on('players-state', (playersState) => {
                Object.entries(playersState).forEach(([playerId, state]) => {
                    if (playerId === myPlayerId) {
                        // Atualizar pr√≥prias vidas
                        if (state.lives !== undefined && state.lives !== playerLives) {
                            playerLives = state.lives;
                            document.getElementById('lives-count').innerText = playerLives;
                        }

                        // Atualizar posi√ß√£o se estava respawnando
                        if (state.isRespawning === false && isRespawning === true) {
                            playerGroup.position.set(state.position.x, state.position.y, state.position.z);
                            health = state.health;
                            armor = state.armor;
                        }

                        isRespawning = state.isRespawning || false;
                    } else if (remotePlayers.has(playerId)) {
                        const remotePlayer = remotePlayers.get(playerId);
                        remotePlayer.state = state;
                    }
                });
            });

            socket.on('game-over', (data) => {
                let title = "FIM DE JOGO";
                let body = "";

                if (data.teamId) {
                    // Vit√≥ria por equipe
                    const isMyTeam = data.teamId === myTeamId;
                    if (isMyTeam) {
                        title = "BOOYAH!";
                        body = "Sua equipe venceu!";
                    } else {
                        title = "DERROTA";
                        body = "Outra equipe venceu";
                    }
                } else if (data.winnerId === myPlayerId) {
                    title = "BOOYAH!";
                    body = "Voc√™ venceu a partida!";
                } else {
                    title = "DERROTA";
                    body = `${data.winnerName} venceu`;
                }

                // Mostrar mensagem com bot√£o de retorno
                const panel = document.getElementById('game-msg');
                document.getElementById('msg-title').innerText = title;
                document.getElementById('msg-body').innerText = body;

                // Limpar bot√µes antigos
                const existingBtn = document.getElementById('btn-return-lobby');
                if (existingBtn) existingBtn.remove();

                const btn = document.createElement('button');
                btn.id = 'btn-return-lobby';
                btn.className = 'menu-btn';
                btn.style.marginTop = '20px';
                btn.innerText = 'VOLTAR AO LOBBY';
                btn.onclick = () => {
                    socket.emit('player-restart');
                    btn.innerText = 'AGUARDANDO...';
                    btn.disabled = true;
                };

                document.getElementById('msg-content').appendChild(btn); // Assume estrutura
                panel.style.display = 'block';
                isPlaying = false;
                document.exitPointerLock();
            });

            // NOVO: Sala reiniciada pelo host
            socket.on('room-reset', () => {
                document.getElementById('game-msg').style.display = 'none';
                document.getElementById('game-container').style.display = 'none';
                document.getElementById('hud').style.display = 'none';
                document.getElementById('lobby-screen').classList.remove('hidden'); // Volta pro lobby da sala

                // Se for host, reabilita o bot√£o de iniciar
                if (isHost) {
                    document.getElementById('lobby-start-btn').style.display = 'block';
                    document.getElementById('lobby-waiting-msg').style.display = 'none';
                } else {
                    document.getElementById('lobby-start-btn').style.display = 'none';
                    document.getElementById('lobby-waiting-msg').style.display = 'block';
                }

                // Resetar vari√°veis locais
                bots = [];
                grenades = [];
                medkits = [];
                isPlaying = false;
                isPaused = false;
            });
        }

        // Atualizar jogadores remotos
        function updateRemotePlayers() {
            if (!isMultiplayer) return;

            remotePlayers.forEach((playerData, playerId) => {
                if (playerData.state && playerData.model) {
                    // Interpolar posi√ß√£o
                    const targetPos = new THREE.Vector3(playerData.state.position.x, playerData.state.position.y, playerData.state.position.z);
                    playerData.model.position.lerp(targetPos, 0.3);

                    // Rota√ß√£o
                    if (playerData.state.rotation) {
                        playerData.model.rotation.y = THREE.MathUtils.lerp(playerData.model.rotation.y, playerData.state.rotation.yaw, 0.3);
                    }

                    // Atualizar nametag
                    if (playerData.nametag && camera) {
                        const screenPos = playerData.model.position.clone();
                        screenPos.y += 6;
                        screenPos.project(camera);

                        const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                        const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;

                        playerData.nametag.style.left = `${x}px`;
                        playerData.nametag.style.top = `${y - 20}px`;
                        playerData.nametag.style.display = screenPos.z < 1 ? 'block' : 'none';
                    }
                }
            });

            // Atualizar ping
            const now = Date.now();
            if (socket && now - lastPingTime > 1000) {
                lastPingTime = now;
                const start = Date.now();
                socket.emit('ping', start);
                socket.once('pong', () => {
                    const ping = Date.now() - start;
                    const pingEl = document.getElementById('ping-value');
                    if (pingEl) pingEl.innerText = ping;
                });
            }
        }

        // NOVO: Criar jogador remoto com cores de equipe
        function createRemotePlayer(playerState) {
            // Criar modelo 3D simples do jogador
            const group = new THREE.Group();

            // Corpo
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 3, 0.8),
                new THREE.MeshStandardMaterial({ color: 0x1d7f7f })
            );
            body.position.y = 1.5;
            group.add(body);

            // Cabe√ßa
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.9, 0.9, 0.9),
                new THREE.MeshStandardMaterial({ color: 0xffdbac })
            );
            head.position.y = 3.5;
            group.add(head);

            group.position.set(playerState.position.x, playerState.position.y, playerState.position.z);
            scene.add(group);

            // Criar nametag
            const nametag = document.createElement('div');
            nametag.className = 'nametag';
            nametag.innerText = playerState.name;

            // NOVO: Aplicar cor da equipe
            if (gameMode !== 'solo' && playerState.teamId) {
                // Encontrar √≠ndice da equipe
                const allTeamIds = new Set();
                allTeamIds.add(myTeamId);
                remotePlayers.forEach(p => {
                    if (p.state?.teamId) allTeamIds.add(p.state.teamId);
                });
                if (playerState.teamId) allTeamIds.add(playerState.teamId);

                const teamArray = Array.from(allTeamIds).sort();
                const teamIndex = teamArray.indexOf(playerState.teamId);
                const teamColor = teamColors[teamIndex] || teamColors[0];

                nametag.style.borderColor = teamColor;
                nametag.style.color = teamColor;

                // Destacar membros da mesma equipe
                if (playerState.teamId === myTeamId) {
                    nametag.style.fontWeight = '900';
                    nametag.style.textShadow = `0 0 5px ${teamColor}`;
                }
            }

            document.body.appendChild(nametag);

            remotePlayers.set(playerState.id, { model: group, nametag, state: playerState });
        }

        const bulletGeo = new THREE.SphereGeometry(0.45, 8, 8);
        const bulletMatYellow = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(160, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'sniper') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'exp') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(20, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1, audioCtx.currentTime + 2.0);
                gain.gain.setValueAtTime(1.0, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2.0);
                osc.start(); osc.stop(audioCtx.currentTime + 2.0);
            } else if (type === 'hit') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
                osc.start(); osc.stop(audioCtx.currentTime + 0.05);
            }
        }

        window.toggleFullscreen = () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => { }); else if (document.exitFullscreen) document.exitFullscreen(); };

        document.addEventListener('touchstart', function forceFS() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => { });
            document.removeEventListener('touchstart', forceFS);
        }, { once: true });

        window.updateLiveSettings = (type, val) => { if (type === 'sens') cfg.sens = parseFloat(val) * 0.0003; if (type === 'fov') { cfg.fov = parseInt(val); if (camera && !isADS) { camera.fov = cfg.fov; camera.updateProjectionMatrix(); } } };
        window.togglePauseMenu = () => { if (isPlaying) { isPaused = !isPaused; document.getElementById('pause-menu').classList.toggle('hidden', !isPaused); } };

        window.toggleHudEdit = () => {
            isEditingHud = !isEditingHud;
            const hudEls = document.querySelectorAll('.hud-el');
            const saveBtn = document.getElementById('save-hud-btn');
            const startScreen = document.getElementById('start-screen');
            const pauseMenu = document.getElementById('pause-menu');
            const hudContainer = document.getElementById('hud');

            if (isEditingHud) {
                startScreen.classList.add('hidden'); pauseMenu.classList.add('hidden');
                hudContainer.style.display = 'block'; hudContainer.style.pointerEvents = 'auto'; saveBtn.style.display = 'block';
                hudEls.forEach(el => { el.classList.add('dragging'); el.addEventListener('touchstart', onHudTouchStart, { passive: false }); });
            } else {
                hudContainer.style.pointerEvents = 'none'; saveBtn.style.display = 'none';
                if (!isPlaying) startScreen.classList.remove('hidden'); else if (isPaused) pauseMenu.classList.remove('hidden');
                hudEls.forEach(el => { el.classList.remove('dragging'); el.removeEventListener('touchstart', onHudTouchStart); });
                saveHudPositions();
            }
        };

        function onHudTouchStart(e) {
            if (!isEditingHud) return;
            const item = e.currentTarget; const touch = e.touches[0]; const rect = item.getBoundingClientRect();
            const offsetX = touch.clientX - rect.left; const offsetY = touch.clientY - rect.top;
            const moveHandler = (moveEvent) => { moveEvent.preventDefault(); const t = moveEvent.touches[0]; item.style.bottom = 'auto'; item.style.right = 'auto'; item.style.left = (t.clientX - offsetX) + 'px'; item.style.top = (t.clientY - offsetY) + 'px'; };
            const endHandler = () => { window.removeEventListener('touchmove', moveHandler); window.removeEventListener('touchend', endHandler); };
            window.addEventListener('touchmove', moveHandler, { passive: false }); window.addEventListener('touchend', endHandler);
        }

        function saveHudPositions() {
            const data = {}; document.querySelectorAll('.hud-el').forEach(el => { data[el.id] = { left: el.style.left, top: el.style.top }; });
            localStorage.setItem('canaa_hud_v3', JSON.stringify(data));
        }

        function triggerHitmarker() { const hm = document.getElementById('hitmarker'); hm.style.display = 'block'; playSfx('hit'); setTimeout(() => hm.style.display = 'none', 100); }
        function addKillLog(msg) { const log = document.getElementById('kill-log'); const entry = document.createElement('div'); entry.className = 'kill-entry'; entry.innerText = msg; log.appendChild(entry); setTimeout(() => entry.remove(), 4000); }

        window.initGame = () => {
            saveGeneralConfigs();
            toggleFullscreen();
            initialBotCount = parseInt(document.getElementById('bot-count').value);
            cfg.bots = initialBotCount;
            cfg.diff = parseInt(document.getElementById('bot-diff').value);
            cfg.sens = parseInt(document.getElementById('cfg-sens').value) * 0.0003;
            cfg.fov = parseInt(document.getElementById('cfg-fov').value);
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            setupThree(); setupMinimap(); isPlaying = true; startZoneTimer();
        };

        function showMsg(title, body) {
            isPlaying = false;
            const panel = document.getElementById('game-msg');
            document.getElementById('msg-title').innerText = title;
            document.getElementById('msg-body').innerText = body;
            panel.style.display = 'block';

            // Garantir que btn-return-lobby n√£o exista se for msg gen√©rica
            const btn = document.getElementById('btn-return-lobby');
            if (btn) btn.remove();
        }

        function setupMinimap() { minimapCanvas = document.getElementById('minimap-canvas'); minimapCanvas.width = 100; minimapCanvas.height = 100; minimapCtx = minimapCanvas.getContext('2d'); }
        function updateMinimap() {
            if (!minimapCtx) return;
            const ctx = minimapCtx; const w = 100, h = 100, mapScale = 0.12;
            ctx.clearRect(0, 0, w, h); ctx.fillStyle = "rgba(10, 20, 40, 0.8)"; ctx.fillRect(0, 0, w, h);
            const cx = w / 2, cz = h / 2;
            ctx.strokeStyle = "rgba(255, 234, 0, 0.5)"; ctx.lineWidth = 2; ctx.beginPath();
            ctx.arc(cx, cz, zoneRadius * mapScale, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = "#ff4444";
            bots.forEach(bot => {
                const bx = cx + (bot.position.x - playerGroup.position.x) * mapScale;
                const bz = cz + (bot.position.z - playerGroup.position.z) * mapScale;
                if (bx > 0 && bx < w && bz > 0 && bz < h) { ctx.beginPath(); ctx.arc(bx, bz, 2.5, 0, Math.PI * 2); ctx.fill(); }
            });
            ctx.fillStyle = "#00ff00"; ctx.beginPath(); ctx.arc(cx, cz, 3.5, 0, Math.PI * 2); ctx.fill();
        }

        function createNPCHealthBar() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 8;
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(material); sprite.scale.set(3.0, 0.4, 1); sprite.position.y = 4.8;
            sprite.userData = { canvas, texture }; return sprite;
        }
        function updateNPCHealthBar(sprite, hp) { const { canvas, texture } = sprite.userData; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, 64, 8); ctx.fillStyle = hp > 50 ? '#0f0' : hp > 20 ? '#ff0' : '#f00'; ctx.fillRect(0, 0, (hp / 100) * 64, 8); texture.needsUpdate = true; }

        // ============================================
        // SISTEMA DE CARREGAMENTO DE PERSONAGENS GLB
        // ============================================
        const glbCharacterCache = {
            soldier: null,    // Modelo do player principal (Soldier.glb)
            punk: null,       // Modelo do punk player (Punk.glb)
            characterBase: null,  // Modelo dos bots (Character Base.glb)
            assaultRifle: null    // Modelo da arma (Assault Rifle.glb)
        };

        // Fun√ß√£o para carregar todos os modelos de personagens e armas
        function preloadCharacterModels(callback) {
            const loader = new GLTFLoader();
            let loaded = 0;
            const total = 4; // Agora s√£o 4 modelos (3 personagens + 1 arma)

            function checkComplete() {
                loaded++;
                if (loaded === total && callback) callback();
            }

            // Carregar Soldier (Player Principal)
            loader.load('models/Soldier.glb', (gltf) => {
                glbCharacterCache.soldier = gltf.scene;
                gltf.scene.traverse((child) => {
                    if (child.isMesh && child.material) child.material.needsUpdate = true;
                });
                console.log('‚úÖ Soldier.glb carregado');
                checkComplete();
            }, undefined, (error) => {
                console.error('‚ùå Erro ao carregar Soldier.glb:', error);
                checkComplete();
            });

            // Carregar Punk Player
            loader.load('models/Punk.glb', (gltf) => {
                glbCharacterCache.punk = gltf.scene.clone();
                console.log('‚úÖ Punk.glb carregado');
                checkComplete();
            }, undefined, (error) => {
                console.error('‚ùå Erro ao carregar Punk.glb:', error);
                checkComplete();
            });

            // Carregar Character Base (Bots)
            loader.load('models/Character Base.glb', (gltf) => {
                glbCharacterCache.characterBase = gltf.scene.clone();
                console.log('‚úÖ Character Base.glb carregado');
                checkComplete();
            }, undefined, (error) => {
                console.error('‚ùå Erro ao carregar Character Base.glb:', error);
                checkComplete();
            });

            // Carregar Assault Rifle (Arma)
            loader.load('models/Assault Rifle.glb', (gltf) => {
                glbCharacterCache.assaultRifle = gltf.scene.clone();
                console.log('‚úÖ Assault Rifle.glb carregado');
                checkComplete();
            }, undefined, (error) => {
                console.error('‚ùå Erro ao carregar Assault Rifle.glb:', error);
                checkComplete();
            });
        }

        // ============================================
        // SISTEMA DE DETEC√á√ÉO DE OSSOS E ANEXA√á√ÉO DE ARMA
        // ============================================

        // Fun√ß√£o para encontrar ossos (bones) no modelo GLB
        function findBoneByName(model, ...names) {
            let foundBone = null;
            model.traverse((child) => {
                if (foundBone) return;
                if (child.isBone || child.type === 'Bone') {
                    const childName = child.name.toLowerCase();
                    for (let name of names) {
                        if (childName.includes(name.toLowerCase())) {
                            foundBone = child;
                            return;
                        }
                    }
                }
            });
            return foundBone;
        }

        // Fun√ß√£o para detectar todos os ossos importantes
        function detectCharacterBones(model) {
            const bones = {
                rightHand: findBoneByName(model, 'RightHand', 'Hand.R', 'R_Hand', 'right_hand', 'handR'),
                leftHand: findBoneByName(model, 'LeftHand', 'Hand.L', 'L_Hand', 'left_hand', 'handL'),
                rightLeg: findBoneByName(model, 'RightLeg', 'Leg.R', 'R_Leg', 'right_leg', 'legR'),
                leftLeg: findBoneByName(model, 'LeftLeg', 'Leg.L', 'L_Leg', 'left_leg', 'legL'),
                rightArm: findBoneByName(model, 'RightArm', 'Arm.R', 'R_Arm', 'right_arm', 'armR'),
                leftArm: findBoneByName(model, 'LeftArm', 'Arm.L', 'L_Arm', 'left_arm', 'armL'),
                spine: findBoneByName(model, 'Spine', 'spine', 'torso'),
                head: findBoneByName(model, 'Head', 'head')
            };
            return bones;
        }

        // Fun√ß√£o para anexar arma na m√£o do personagem
        function attachWeaponToHand(characterGroup, characterModel) {
            if (!glbCharacterCache.assaultRifle) {
                console.warn(' ‚ö†Ô∏è Assault Rifle n√£o carregada ainda');
                return null;
            }

            const weapon = glbCharacterCache.assaultRifle.clone();
            weapon.scale.set(0.5, 0.5, 0.5);

            weapon.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) child.material.needsUpdate = true;
                }
            });

            const bones = detectCharacterBones(characterModel);

            if (bones.rightHand) {
                bones.rightHand.add(weapon);
                weapon.position.set(0.1, 0, 0);
                weapon.rotation.set(0, Math.PI / 2, 0);
                console.log('‚úÖ Arma anexada ao osso da m√£o direita');
            } else {
                characterModel.add(weapon);
                weapon.position.set(0.2, 0.8, -0.1);
                weapon.rotation.set(0, Math.PI / 2, 0);
                console.log('‚ö†Ô∏è Osso n√£o encontrado, arma em posi√ß√£o fixa');
            }

            return weapon;
        }

        // Fun√ß√£o para criar personagem a partir de GLB
        function createCharacterFromGLB(type, id) {
            let modelTemplate = null;

            if (type === 'player') {
                modelTemplate = glbCharacterCache.soldier;
            } else if (type === 'punk') {
                modelTemplate = glbCharacterCache.punk;
            } else if (type === 'bot') {
                modelTemplate = glbCharacterCache.characterBase;
            }

            // Fallback: se o modelo n√£o carregou, usar procedural
            if (!modelTemplate) {
                console.warn(`‚ö†Ô∏è Modelo GLB "${type}" n√£o dispon√≠vel, usando fallback procedural`);
                return createHumanoidFallback(type === 'player' ? 0x2E7D32 : 0x7f1d1d, id);
            }

            const group = new THREE.Group();
            const model = modelTemplate.clone();

            // Ajustar escala do modelo GLB (pode precisar ajustar dependendo do tamanho original)
            model.scale.set(2, 2, 2);

            // Configurar sombras e materiais
            model.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if (child.material) {
                        child.material.needsUpdate = true;
                        if (!child.material.map && !child.material.color) {
                            child.material.color = new THREE.Color(type === 'player' ? 0x2E7D32 : 0x7f1d1d);
                        }
                    }
                }
            });

            group.add(model);

            // Detectar ossos e anexar arma
            const bones = detectCharacterBones(model);
            const weapon = attachWeaponToHand(group, model);

            // Dados do personagem (compat√≠vel com o sistema antigo)
            group.userData = {
                hp: 100,
                id: id || Math.random(),
                vY: 0,
                glbModel: model,
                bones: bones,  // Ossos detectados
                weapon: weapon,  // Refer√™ncia √† arma
                limbs: {  // Compatibilidade com sistema antigo
                    lLeg: bones.leftLeg,
                    rLeg: bones.rightLeg,
                    lArm: bones.leftArm,
                    rArm: bones.rightArm,
                    weapon: weapon
                }
            };

            return group;
        }

        // Fallback: modelo procedural antigo (caso os GLBs n√£o carreguem)
        function createHumanoidFallback(color, id) {
            const group = new THREE.Group();
            const mB = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
            const mS = new THREE.MeshStandardMaterial({ color: 0xffdbac });
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.65, 0.9, 0.4), mB); torso.position.y = 0.85;
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.45, 0.45), mS); head.position.y = 1.55;
            const helmet = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.25, 0.5), new THREE.MeshStandardMaterial({ color: 0x222222 }));
            helmet.position.y = 0.15; head.add(helmet);
            const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), mB); lLeg.position.set(-0.2, 0.4, 0);
            const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.8, 0.25), mB); rLeg.position.set(0.2, 0.4, 0);
            const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), mB); lArm.position.set(-0.45, 0.9, 0);
            const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.7, 0.2), mB); rArm.position.set(0.45, 0.9, 0);
            const weapon = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.18, 1.2), new THREE.MeshStandardMaterial({ color: 0x111111 }));
            weapon.position.set(0.45, 0.9, -0.5);
            group.add(torso, head, lLeg, rLeg, lArm, rArm, weapon);
            group.userData = { limbs: { lLeg, rLeg, lArm, rArm, weapon }, hp: 100, id: id || Math.random(), vY: 0 };
            group.scale.set(2, 2, 2);
            return group;
        }

        // Manter compatibilidade com c√≥digo antigo (agora usa GLB)
        function createHumanoid(color, id) {
            // Detectar tipo baseado na cor (hack tempor√°rio para compatibilidade)
            let type = 'bot';
            if (color === 0x2E7D32) type = 'player';  // Verde = player
            else if (color === 0x1d7f7f) type = 'punk';  // Ciano = punk (multiplayer remoto)

            return createCharacterFromGLB(type, id);
        }

        // ============================================
        // CARREGAR MODELOS 3D EXTERNOS (QUADRUPLICADO)
        // ============================================
        function loadExternalModelsMP() {
            const loader = new GLTFLoader();

            // MOSTRAR LOADING SCREEN
            const loadingScreen = document.getElementById('loading-screen');
            const loadingProgress = document.getElementById('loading-progress');
            const loadingText = document.getElementById('loading-text');
            if (loadingScreen) loadingScreen.classList.remove('hidden');
            if (loadingProgress) loadingProgress.style.width = '10%';
            if (loadingText) loadingText.innerText = 'Carregando 4 mapas GLB...';

            // Definir 4 posi√ß√µes para os quadrantes (criando mapa 2x maior)
            const mapPositions = [
                { x: -250, z: -250, label: 'Q1 (NW)' },
                { x: 250, z: -250, label: 'Q2 (NE)' },
                { x: -250, z: 250, label: 'Q3 (SW)' },
                { x: 250, z: 250, label: 'Q4 (SE)' }
            ];

            let loadedCount = 0;
            let totalMeshCount = 0;

            // Carregar 4 inst√¢ncias do mapa
            mapPositions.forEach((pos, index) => {
                loader.load(
                    'models/fps canaa Map.glb',
                    function (gltf) {
                        const model = gltf.scene.clone();

                        // Posicionar no quadrante
                        model.position.set(pos.x, 0, pos.z);

                        // Escala AUMENTADA para 12x no multiplayer
                        model.scale.set(12, 12, 12);

                        // Adicionar √† cena
                        scene.add(model);

                        // Configurar sombras e colis√µes
                        let meshCount = 0;
                        model.traverse((child) => {
                            if (child.isMesh && child.geometry) {
                                child.castShadow = true;
                                child.receiveShadow = true;

                                // CR√çTICO: Computar bounding box para colis√µes
                                child.geometry.computeBoundingBox();
                                child.geometry.computeBoundingSphere();

                                // Detectar ch√£o pelo nome
                                const name = child.name.toLowerCase();
                                const isGround = name.includes('floor') || name.includes('ground') || name.includes('terrain') ||
                                    name.includes('road') || name.includes('asphalt') || name.includes('grass') ||
                                    name.includes('sand') || name.includes('sidewalk') || name.includes('chao') || name.includes('plane');

                                // Adicionar colis√µes (exceto objetos decorativos)
                                if (!name.includes('decoration')) {
                                    child.userData.isWall = true; // Todos os objetos n√£o decorativos param balas
                                    if (isGround) child.userData.isGround = true; // Se for ch√£o, n√£o bloqueia movimento via Box
                                    obstacles.push(child);
                                    meshCount++;
                                }
                            }
                        });

                        totalMeshCount += meshCount;
                        loadedCount++;

                        // Atualizar progresso
                        const progress = 30 + (loadedCount / mapPositions.length) * 50;
                        if (loadingProgress) loadingProgress.style.width = `${progress}%`;
                        if (loadingText) loadingText.innerText = `Carregando ${loadedCount}/${mapPositions.length} mapas...`;

                        // Atualizar collision boxes ap√≥s carregar √∫ltima inst√¢ncia
                        if (loadedCount === mapPositions.length) {
                            if (loadingProgress) loadingProgress.style.width = '90%';
                            if (loadingText) loadingText.innerText = 'Configurando colis√µes...';

                            scene.updateMatrixWorld(true);
                            updateCollisionBoxes();
                            console.log(`‚úÖ Todos os 4 mapas GLB foram carregados! ${totalMeshCount} objetos com colis√£o`);

                            // OCULTAR LOADING SCREEN
                            if (loadingProgress) loadingProgress.style.width = '100%';
                            if (loadingText) loadingText.innerText = 'Conclu√≠do!';
                            setTimeout(() => {
                                if (loadingScreen) loadingScreen.classList.add('hidden');

                                // INICIAR JOGO AGORA (ap√≥s todos os 4 mapas carregarem)
                                isPlaying = true;
                                startZoneTimer();
                                console.log('üéÆ Jogo multiplayer iniciado ap√≥s carregamento de 4 mapas');
                            }, 500);
                        }

                        console.log(`‚úÖ Mapa ${pos.label} carregado (${loadedCount}/${mapPositions.length}) - ${meshCount} objetos`);
                    },
                    (xhr) => {
                        const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                        console.log(`üì¶ Carregando mapa ${pos.label}: ${percent}%`);
                    },
                    (error) => {
                        console.error(`‚ùå Erro ao carregar mapa ${pos.label}:`, error);
                        console.error('Verifique se o arquivo "fps canaa Map.glb" est√° na pasta models/');
                    }
                );
            });
        }

        function updateCollisionBoxes() {
            obstacleBoxes = [];
            obstacles.forEach(o => {
                if (o.geometry && o.userData.isSolid !== false && !o.userData.isGround) {
                    const b = new THREE.Box3().setFromObject(o);
                    b.userData = o.userData;
                    obstacleBoxes.push(b);
                }
            });
        }

        // ============================================
        // INPUTS E CONTROLES (CS-STYLE)
        // ============================================
        // ============================================
        // INPUTS E CONTROLES (CS-STYLE)
        // ===========================================
        let inputsSetup = false;
        function setupInputs() {
            if (inputsSetup) return;
            inputsSetup = true;
            // Mouse (C√¢mera e Tiro)
            document.addEventListener('mousedown', (e) => {
                if (!isPlaying || isPaused) return;

                // Travar ponteiro ao clicar
                if (document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                    return;
                }

                if (e.button === 0) { // Bot√£o esquerdo
                    isShooting = true;
                    if (currentWeapon === 'AR') fireFocusTimer = 0;
                } else if (e.button === 2) { // Bot√£o direito
                    isADS = true;
                    if (currentWeapon === 'SNIPER') document.getElementById('sniper-scope').style.display = 'block';
                    camera.fov = currentWeapon === 'SNIPER' ? 12 : 30;
                    camera.updateProjectionMatrix();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) isShooting = false;
                if (e.button === 2) {
                    isADS = false;
                    document.getElementById('sniper-scope').style.display = 'none';
                    camera.fov = cfg.fov;
                    camera.updateProjectionMatrix();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body && !isPaused && isPlaying) {
                    const sens = cfg.sens || 0.002;
                    cameraYaw -= e.movementX * sens;
                    cameraPitch -= e.movementY * sens;
                    // Limitar √¢ngulo pra n√£o girar 360 verticalmente
                    cameraPitch = Math.max(-1.4, Math.min(1.4, cameraPitch));
                }
            });

            document.addEventListener('keydown', (e) => {
                if (!isPlaying) return;

                if (e.code === 'Escape') {
                    togglePauseMenu();
                    if (isPaused) document.exitPointerLock();
                    else document.body.requestPointerLock();
                    return;
                }

                if (isPaused) return;
                keys[e.code] = true;

                if (e.code === 'KeyR') console.log('Recarregando...');
                if (e.code === 'Space' && jumps < 2) { vY = 0.8; jumps++; }
                if (e.code === 'Digit1') currentWeapon = 'AR';
                if (e.code === 'Digit2') currentWeapon = 'SNIPER';
                if (e.code === 'KeyF') {
                    grenadeType = grenadeType === 'explosive' ? 'smoke' : 'explosive';
                }
                if (e.code === 'ShiftLeft') isRunning = true;
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'ShiftLeft') isRunning = false;
            });
        }

        function updateBotsNetworking() {
            if (!isHost || !socket || !isPlaying) return;
            const now = Date.now();
            if (now - lastBotUpdate < 100) return;
            lastBotUpdate = now;

            const botsData = bots.map(b => ({
                pos: { x: b.position.x, y: b.position.y, z: b.position.z },
                rot: b.rotation.y,
                health: b.userData.hp
            }));
            socket.emit('update-bots', botsData);
        }

        let animationId;
        function setupThree() {
            if (animationId) cancelAnimationFrame(animationId);
            document.getElementById('game-container').innerHTML = '';
            obstacles = []; medkits = []; bullets = []; grenades = []; effects = []; houseData = [];

            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0006);
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(cfg.fov, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.1); sunLight.position.set(300, 500, 100); sunLight.castShadow = true;
            sunLight.shadow.camera.left = -800; sunLight.shadow.camera.right = 800; sunLight.shadow.camera.top = 800; sunLight.shadow.camera.bottom = -800;
            sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048; scene.add(sunLight);
            sunObj = new THREE.Mesh(new THREE.SphereGeometry(25, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffff00 })); sunObj.position.set(400, 600, 200); scene.add(sunObj);

            createWorld();

            zoneMesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1500, 64, 1, true), new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide }));
            zoneMesh.scale.set(zoneRadius, 1, zoneRadius); zoneMesh.position.y = 750; scene.add(zoneMesh);

            setupInputs(); // Use setupInputs (tem pointer lock) em vez de setupGameInput
            scene.updateMatrixWorld(true);
            updateCollisionBoxes();
            animate();

            // CARREGAR MODELOS GLB E CRIAR PERSONAGENS DEPOIS
            preloadCharacterModels(() => {
                console.log('üéÆ Todos os modelos de personagens carregados!');

                // Criar player AP√ìS GLBs carregarem
                playerGroup = new THREE.Group();
                charModel = createHumanoid(0x2E7D32, 'player');
                playerGroup.add(charModel);
                scene.add(playerGroup);
                playerGroup.position.set(30, 2, 0);

                // Criar bots AP√ìS GLBs carregarem
                setupBotsPeriphery();
            });
        }

        // updateCollisionBoxes() j√° definida na linha 2280 - duplicata removida

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 12, 8), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
            trunk.position.y = 6;
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(6, 16, 8), new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.8 }));
            leaves.position.y = 16;
            group.add(trunk, leaves);
            group.position.set(x, 0, z);
            group.userData.isTree = true;
            scene.add(group);
            obstacles.push(trunk);
        }

        function createLighthouse(x, z) {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(8, 12, 60, 16), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            base.position.y = 30;
            const top = new THREE.Mesh(new THREE.CylinderGeometry(10, 8, 8, 16), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            top.position.y = 64;
            const glass = new THREE.Mesh(new THREE.CylinderGeometry(6, 6, 8, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 }));
            glass.position.y = 72;
            const dome = new THREE.Mesh(new THREE.SphereGeometry(7, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            dome.position.y = 76;

            const spot = new THREE.SpotLight(0xffffff, 5, 400, Math.PI / 6, 0.5);
            spot.position.set(0, 72, 0);
            spot.target.position.set(100, 0, 0);
            group.add(base, top, glass, dome, spot, spot.target);
            group.position.set(x, 0, z);
            scene.add(group);
            obstacles.push(base, top, dome);

            group.userData.update = (t) => {
                spot.target.position.x = Math.cos(t) * 100;
                spot.target.position.z = Math.sin(t) * 100;
            };
            effects.push({ m: group, type: 'lighthouse' });
        }

        function createDetailedHouse(x, z) {
            const group = new THREE.Group();
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.8 });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8d4925 });
            const winMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.8 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4d2911 });
            const h = 10, s = 24, t = 1.0;

            const walls = [
                { size: [t, h, s], pos: [-s / 2, h / 2, 0] }, { size: [t, h, s], pos: [s / 2, h / 2, 0] }, { size: [s, h, t], pos: [0, h / 2, -s / 2] },
                { size: [8, h, t], pos: [-s / 2 + 4, h / 2, s / 2] }, { size: [6, h, t], pos: [s / 2 - 3, h / 2, s / 2] }
            ];
            walls.forEach(w => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
                m.position.set(...w.pos);
                m.castShadow = true; m.receiveShadow = true;
                m.userData.isWall = true;
                group.add(m); obstacles.push(m);
            });

            const roof = new THREE.Mesh(new THREE.ConeGeometry(s * 0.85, 8, 4), roofMat);
            roof.position.y = h + 4;
            roof.rotation.y = Math.PI / 4;
            roof.userData.isWall = true;
            group.add(roof); obstacles.push(roof);

            const door = new THREE.Mesh(new THREE.BoxGeometry(3.5, 6.5, 0.3), doorMat); door.position.set(-s / 4, 3.25, s / 2 + 0.1); door.userData.isDoor = true; group.add(door);

            const createWin = (px, py, pz, rotY) => {
                const w = new THREE.Mesh(new THREE.BoxGeometry(4.5, 4.5, 0.4), winMat);
                w.position.set(px, py, pz);
                if (rotY) w.rotation.y = rotY;
                group.add(w);
            };
            createWin(s / 4, 6, s / 2 + 0.1, 0);
            createWin(s / 2 + 0.1, 6, 0, Math.PI / 2);
            createWin(-s / 2 - 0.1, 6, 0, -Math.PI / 2);

            const mk = new THREE.Group();
            const mkBox = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            const mkCrossH = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.3, 0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            const mkCrossV = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            mkCrossH.position.z = 0.61; mkCrossV.position.z = 0.61; mk.add(mkBox, mkCrossH, mkCrossV);
            mk.position.set(0, 1, 0); mk.userData.isMedkit = true; group.add(mk); medkits.push(mk);

            group.position.set(x, 0, z);
            group.userData.isHouse = true;
            scene.add(group);
            houseData.push({ position: new THREE.Vector3(x, 2, z), botsInside: 0, botsAssigned: [] });
        }

        function createMountains() {
            const mountainMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 1 });
            for (let i = 0; i < 48; i++) {
                const angle = (i / 48) * Math.PI * 2;
                const dist = 1000 + Math.random() * 400;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const height = 180 + Math.random() * 250;
                const width = 250 + Math.random() * 300;
                const mountain = new THREE.Mesh(new THREE.ConeGeometry(width, height, 4), mountainMat);
                mountain.position.set(x, height / 2 - 5, z);
                mountain.rotation.y = Math.random() * Math.PI;
                mountain.userData.isGround = true;
                mountain.userData.isWall = true;
                scene.add(mountain);
                obstacles.push(mountain);
            }
        }

        function createWorld() {
            // MUNDO PROCEDURAL REMOVIDO - USANDO APENAS MAPAS GLB
            // Todo o cen√°rio vem dos arquivos GLB carregados em loadExternalModelsMP()
        }

        function setupBotsPeriphery() {
            const botHP = [125, 225, 375][cfg.diff - 1];
            for (let i = 0; i < initialBotCount; i++) {
                const bot = createHumanoid(0x7f1d1d, `bot_${i}`);
                const angle = Math.random() * Math.PI * 2;
                const spawnRadius = 850;
                bot.position.set(Math.cos(angle) * spawnRadius, 0, Math.sin(angle) * spawnRadius);
                bot.userData.isAggressive = Math.random() < 0.3;
                bot.userData.willShootOutside = Math.random() < 0.5;
                bot.userData.currentHouse = null;
                bot.userData.hp = botHP; bot.userData.maxHP = botHP; bot.userData.lastShot = 0; bot.userData.name = `Soldado ${i + 1}`;
                bot.userData.reactionTimer = 0; bot.userData.strafeDir = Math.random() > 0.5 ? 1 : -1;
                bot.userData.strafeTimer = 0; bot.userData.accuracyCharge = 0;
                bot.userData.isSeekingCover = false;
                bot.userData.jumpTimer = Math.random() * 5;
                const hb = createNPCHealthBar(); bot.add(hb); bot.userData.hBar = hb; updateNPCHealthBar(hb, 100);
                scene.add(bot); bots.push(bot);
            }
        }

        function setupGameInput() {
            window.addEventListener('keydown', e => keys[e.code] = true); window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('touchstart', e => {
                if (isEditingHud || isPaused) return;
                for (let t of e.changedTouches) {
                    if (t.clientX < window.innerWidth / 2.5) moveTouchId = t.identifier;
                    else if (t.target.id === 'btn-fire-ads') {
                        fireTouchId = t.identifier;
                        fireLastX = t.clientX;
                        fireLastY = t.clientY;
                        isShooting = true;
                        isADS = true;
                        fireFocusTimer = 0;
                        camera.fov = currentWeapon === 'SNIPER' ? 12 : 30;
                        camera.updateProjectionMatrix();
                        if (currentWeapon === 'SNIPER') document.getElementById('sniper-scope').style.display = 'block';
                    }
                    else if (t.target.id === 'btn-fire-hip') {
                        fireTouchId = t.identifier;
                        fireLastX = t.clientX;
                        fireLastY = t.clientY;
                        isShooting = true;
                        isADS = false; // Disparo normal (curta dist√¢ncia)
                        fireFocusTimer = 10; // For√ßa disparo imediato
                        camera.fov = cfg.fov;
                        camera.updateProjectionMatrix();
                    }
                    else if (!t.target.classList.contains('hud-el')) { lookTouchId = t.identifier; lastX = t.clientX; lastY = t.clientY; }
                }
            });
            window.addEventListener('touchmove', e => {
                if (isEditingHud || isPaused) return;
                for (let t of e.changedTouches) {
                    if (t.identifier === moveTouchId) {
                        const r = document.getElementById('joy-zone').getBoundingClientRect();
                        let dx = t.clientX - (r.left + r.width / 2), dy = t.clientY - (r.top + r.height / 2);
                        const d = Math.hypot(dx, dy); if (d > 65) { dx *= 65 / d; dy *= 65 / d; }
                        document.getElementById('joy-knob').style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        moveVec.set(dx / 65, -dy / 65);
                    }
                    if (t.identifier === fireTouchId) {
                        cameraYaw -= (t.clientX - fireLastX) * cfg.sens * 0.8;
                        cameraPitch = Math.max(-0.7, Math.min(1.2, cameraPitch - (t.clientY - fireLastY) * cfg.sens * 1.2));
                        fireLastX = t.clientX; fireLastY = t.clientY;
                    }
                    if (t.identifier === lookTouchId) {
                        cameraYaw -= (t.clientX - lastX) * cfg.sens;
                        cameraPitch = Math.max(-0.7, Math.min(1.2, cameraPitch - (t.clientY - lastY) * cfg.sens));
                        lastX = t.clientX; lastY = t.clientY;
                    }
                }
            }, { passive: false });
            window.addEventListener('touchend', e => {
                for (let t of e.changedTouches) {
                    if (t.identifier === moveTouchId) { moveTouchId = null; moveVec.set(0, 0); document.getElementById('joy-knob').style.transform = 'translate(-50%, -50%)'; }
                    if (t.identifier === lookTouchId) lookTouchId = null;
                    if (t.identifier === fireTouchId) {
                        fireTouchId = null;
                        isShooting = false;
                        isADS = false;
                        camera.fov = cfg.fov;
                        camera.updateProjectionMatrix();
                        document.getElementById('sniper-scope').style.display = 'none';
                    }
                }
            });
            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'ShiftLeft') isRunning = false;
            });
            document.getElementById('btn-jump').onpointerdown = () => { if (!isPaused && jumps < 2) { vY = 0.8; jumps++; } };
            document.getElementById('btn-ads').onpointerdown = () => { if (!isPaused) { isADS = true; camera.fov = currentWeapon === 'SNIPER' ? 12 : 30; camera.updateProjectionMatrix(); if (currentWeapon === 'SNIPER') document.getElementById('sniper-scope').style.display = 'block'; } };
            document.getElementById('btn-ads').onpointerup = () => { isADS = false; camera.fov = cfg.fov; camera.updateProjectionMatrix(); document.getElementById('sniper-scope').style.display = 'none'; };
            document.getElementById('btn-settings').onclick = togglePauseMenu;
            document.getElementById('btn-eye').onclick = () => toggleCameraMode();


            document.getElementById('btn-nade').onpointerdown = () => {
                if (!isPlaying || isPaused) return;
                throwGrenade();
            };

            document.getElementById('btn-run').onclick = (e) => { isRunning = !isRunning; e.target.classList.toggle('active', isRunning); };
            document.getElementById('btn-swap-nade').onclick = (e) => { grenadeType = (grenadeType === 'explosive' ? 'smoke' : 'explosive'); e.target.innerHTML = `BOMBA<br>(${grenadeType === 'explosive' ? 'EXPL' : 'FUMA'})`; };
            document.getElementById('btn-switch-weapon').onclick = (e) => { currentWeapon = currentWeapon === 'AR' ? 'SNIPER' : 'AR'; e.target.innerHTML = `ARMA<br>(${currentWeapon === 'AR' ? 'FUZIL' : 'SNIPER'})`; };
        }

        function checkPathObstructedBySmoke(from, to) {
            for (let ef of effects) {
                if (ef.type === 'smoke') {
                    const smokePos = ef.m.position;
                    const distToLine = new THREE.Line3(from, to).closestPointToPoint(smokePos, true, new THREE.Vector3()).distanceTo(smokePos);
                    if (distToLine < (ef.m.scale.x * 6.0)) return true;
                }
            }
            return false;
        }

        function spawnBullet(owner, from, target, ownerId, accuracyBonus = 0) {
            if (checkPathObstructedBySmoke(from, target)) return;
            const dir = target.clone().sub(from).normalize();
            if (owner === 'bot') {
                const spread = Math.max(0, 0.05 - accuracyBonus);
                dir.x += (Math.random() - 0.5) * spread; dir.y += (Math.random() - 0.5) * spread; dir.z += (Math.random() - 0.5) * spread;
                dir.normalize();
            }
            const checkOrigin = new THREE.Raycaster(from, dir, 0, 2.5);
            const originHits = checkOrigin.intersectObjects(obstacles);
            if (originHits.length > 0 && originHits[0].object.userData.isWall) return;
            const startPos = from.clone().add(dir.clone().multiplyScalar(2.2));
            const b = new THREE.Mesh(bulletGeo, bulletMatYellow);
            b.position.copy(startPos);
            // Ajuste velocidade bala 
            // 9.5 per frame approx => 9.5 * 60 = 570
            // Sniper 14.0 per frame approx => 840
            const speed = (owner === 'player' && currentWeapon === 'SNIPER') ? 800 : 540;
            // Guardamos VELOCIDADE REAL em unidades por segundo
            b.userData = { vel: dir.multiplyScalar(speed), life: 4.0, owner, ownerId, prevPos: startPos.clone() };
            bullets.push(b); scene.add(b);
            if (owner === 'player') playSfx(currentWeapon === 'SNIPER' ? 'sniper' : 'shoot');
        }

        // ============================================
        // SISTEMA DE ANIMA√á√ïES PROCEDURAIS
        // ============================================
        function animateCharacter(characterGroup, state) {
            if (!characterGroup || !characterGroup.userData) return;

            const { bones, glbModel } = characterGroup.userData;
            if (!bones) return; // Sem ossos detectados, n√£o animar

            const { isWalking, isJumping, isShooting, speed, time, jumpVelocity } = state;

            // ANIMA√á√ÉO DE CAMINHADA (Walking)
            if (isWalking && bones.leftLeg && bones.rightLeg) {
                const walkSpeed = speed * 15; // Intensidade da anima√ß√£o
                const swing = Math.sin(time * walkSpeed) * 0.5;

                // Rotacionar pernas alternadamente
                bones.leftLeg.rotation.x = swing;
                bones.rightLeg.rotation.x = -swing;

                // Bra√ßos tamb√©m balan√ßam (inverso das pernas)
                if (bones.leftArm && bones.rightArm) {
                    bones.leftArm.rotation.x = -swing * 0.3;
                    bones.rightArm.rotation.x = swing * 0.3;
                }
            } else {
                // Resetar para posi√ß√£o neutra quando parado
                if (bones.leftLeg) bones.leftLeg.rotation.x = 0;
                if (bones.rightLeg) bones.rightLeg.rotation.x = 0;
                if (bones.leftArm) bones.leftArm.rotation.x = 0;
                if (bones.rightArm) bones.rightArm.rotation.x = 0;
            }

            // ANIMA√á√ÉO DE PULO (Jump)
            if (isJumping) {
                if (jumpVelocity > 0) {
                    // Subindo - pernas flexionadas, bra√ßos pra cima
                    if (bones.leftLeg) bones.leftLeg.rotation.x = Math.PI / 6;
                    if (bones.rightLeg) bones.rightLeg.rotation.x = Math.PI / 6;
                    if (bones.leftArm) bones.leftArm.rotation.x = -Math.PI / 4;
                    if (bones.rightArm) bones.rightArm.rotation.x = -Math.PI / 4;
                } else {
                    // Descendo - pernas estendidas preparando aterrissagem
                    if (bones.leftLeg) bones.leftLeg.rotation.x = -Math.PI / 8;
                    if (bones.rightLeg) bones.rightLeg.rotation.x = -Math.PI / 8;
                }
            }

            // ANIMA√á√ÉO DE TIRO (Shooting) - Recuo da arma
            if (isShooting && characterGroup.userData.weapon) {
                const weapon = characterGroup.userData.weapon;

                // Recuo r√°pido
                if (bones.rightHand) {
                    bones.rightHand.rotation.x = Math.sin(time * 50) * 0.1;
                }

                // Pequeno shake na arma
                weapon.rotation.z = Math.sin(time * 40) * 0.05;
            }

            // ANIMA√á√ÉO IDLE (Respira√ß√£o sutil)
            if (!isWalking && !isJumping && bones.spine) {
                bones.spine.rotation.y = Math.sin(time * 2) * 0.02;
                bones.spine.position.y = Math.sin(time * 3) * 0.01;
            }
        }

        function startZoneTimer() { zoneActive = true; }

        function animate() {
            animationId = requestAnimationFrame(animate);
            updateBotsNetworking(); // Sync Bots
            if (!isPlaying || isPaused) return;

            // DELTA TIME (Limited to avoid huge jumps on lag spikes)
            const rawDelta = clock.getDelta();
            const dt = Math.min(0.1, rawDelta);
            const time = clock.getElapsedTime();

            charModel.rotation.y = THREE.MathUtils.lerp(charModel.rotation.y, cameraYaw, 10 * dt);

            if (uiCache.alive) uiCache.alive.innerText = bots.length + (health > 0 ? 1 : 0);
            if (uiCache.dead) uiCache.dead.innerText = (initialBotCount + 1) - (bots.length + (health > 0 ? 1 : 0));
            if (uiCache.kills) uiCache.kills.innerText = playerKills;

            let inputX = moveVec.x; let inputY = moveVec.y;
            if (keys['KeyW']) inputY = 1; if (keys['KeyS']) inputY = -1;
            if (keys['KeyA']) inputX = -1; if (keys['KeyD']) inputX = 1;

            // Ajustar velocidade com DeltaTime
            // Base speed was roughly 0.8 per frame @ 60fps => 0.8 * 60 = 48 units/sec
            const speed = (isRunning ? 70 : 48) * (isADS ? 0.4 : 1) * dt;

            if (Math.hypot(inputX, inputY) > 0.1) {
                const moveAngle = Math.atan2(-inputX, inputY);
                const moveDir = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw + moveAngle);
                const nextX = playerGroup.position.clone().add(new THREE.Vector3(moveDir.x, 0, 0).multiplyScalar(speed));
                const nextZ = playerGroup.position.clone().add(new THREE.Vector3(0, 0, moveDir.z).multiplyScalar(speed));
                const pBoxX = new THREE.Box3().setFromCenterAndSize(nextX.clone().add(new THREE.Vector3(0, 2.5, 0)), new THREE.Vector3(0.4, 3.4, 0.4));
                const pBoxZ = new THREE.Box3().setFromCenterAndSize(nextZ.clone().add(new THREE.Vector3(0, 2.5, 0)), new THREE.Vector3(0.4, 3.4, 0.4));
                let hitX = false, hitZ = false;
                for (let i = 0; i < obstacleBoxes.length; i++) {
                    const box = obstacleBoxes[i];
                    if (box.userData?.isRamp) continue;
                    if (!hitX && pBoxX.intersectsBox(box)) hitX = true;
                    if (!hitZ && pBoxZ.intersectsBox(box)) hitZ = true;
                }
                if (!hitX) playerGroup.position.x = nextX.x;
                if (!hitZ) playerGroup.position.z = nextZ.z;
            }

            for (let i = medkits.length - 1; i >= 0; i--) {
                const mk = medkits[i]; const worldPos = new THREE.Vector3(); mk.getWorldPosition(worldPos);
                if (playerGroup.position.distanceTo(worldPos) < 6) { health = Math.min(100, health + 40); scene.remove(mk); medkits.splice(i, 1); playSfx('hit'); continue; }
                for (let bot of bots) { if (bot.position.distanceTo(worldPos) < 6 && bot.userData.hp < bot.userData.maxHP) { bot.userData.hp = Math.min(bot.userData.maxHP, bot.userData.hp + 40); scene.remove(mk); medkits.splice(i, 1); playSfx('hit'); break; } }
            }

            playerGroup.position.y += vY * (dt * 60);
            const rayFloor = new THREE.Raycaster(playerGroup.position.clone().add(new THREE.Vector3(0, 8.0, 0)), new THREE.Vector3(0, -1, 0));
            const floorHits = rayFloor.intersectObjects(obstacles);
            let floorY = 0; if (floorHits.length > 0) floorY = floorHits[0].point.y;
            if (playerGroup.position.y > floorY + 0.15) vY -= 0.025 * (dt * 60); else { playerGroup.position.y = floorY; vY = 0; jumps = 0; }

            // ANIMAR PERSONAGEM DO PLAYER (DEPOIS de calcular floorY)
            const isWalking = Math.hypot(inputX, inputY) > 0.1;
            const isJumping = playerGroup.position.y > floorY + 0.2;
            animateCharacter(playerGroup, {
                isWalking: isWalking,
                isJumping: isJumping,
                isShooting: isShooting,
                speed: isWalking ? (isRunning ? 1.5 : 1.0) : 0,
                time: time,
                jumpVelocity: vY
            });

            if (gasPauseTimer > 0) gasPauseTimer -= dt;
            if (zoneActive && zoneRadius > 10) {
                if (gasPauseTimer <= 0) {
                    if ((gasPauseCount === 0 && zoneRadius <= 350) || (gasPauseCount === 1 && zoneRadius <= 150)) {
                        gasPauseCount++; gasPauseTimer = 30;
                    } else {
                        zoneRadius -= 7.2 * dt; // 0.12 * 60 = 7.2
                        zoneMesh.scale.set(zoneRadius, 1, zoneRadius);
                    }
                }
                if (Math.hypot(playerGroup.position.x, playerGroup.position.z) > zoneRadius) { health -= 3.0 * dt; lastDamageTime = time; } // 0.05 * 60 = 3
                if (gasPauseTimer > 0 && uiCache.timer) uiCache.timer.innerText = `PR√ìX. ZONA EM: ${Math.ceil(gasPauseTimer)}s`;
                else if (uiCache.timer) uiCache.timer.innerText = `ZONA EM MOVIMENTO`;
            }
            if (time - lastDamageTime > 6 && armor < 100) armor = Math.min(100, armor + 9.0 * dt); // 0.15 * 60 = 9.0
            if (uiCache.health) uiCache.health.style.width = health + '%';
            if (uiCache.armor) uiCache.armor.style.width = armor + '%';

            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i];
                if (!g.userData.hasStopped) {
                    g.position.add(g.userData.vel.clone().multiplyScalar(dt * 60)); // Ajuste para manter velocidade
                    g.userData.vel.y -= 0.025 * (dt * 60);
                    const gRay = new THREE.Raycaster(g.position, g.userData.vel.clone().normalize(), 0, g.userData.vel.length() + 0.5);
                    const gHits = gRay.intersectObjects(obstacles);
                    if (gHits.length > 0 || g.position.y < 0.25) {
                        g.userData.hasStopped = true;
                        g.userData.vel.set(0, 0, 0);
                        if (g.position.y < 0.25) g.position.y = 0.25;
                    }
                }
                if (--g.userData.life <= 0) {
                    if (g.userData.type === 'explosive') {
                        playSfx('exp');
                        for (let k = 0; k < 15; k++) {
                            const p = new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.9 }));
                            p.position.copy(g.position).add(new THREE.Vector3((Math.random() - 0.5) * 5, Math.random() * 3, (Math.random() - 0.5) * 5));
                            scene.add(p); effects.push({ m: p, l: 45, type: 'explosion' });
                        }
                        bots.forEach(b => { if (b.position.distanceTo(g.position) < 30) b.userData.hp -= 200; });
                    } else {
                        for (let j = 0; j < 35; j++) {
                            const smk = new THREE.Mesh(new THREE.SphereGeometry(12, 12, 12), new THREE.MeshStandardMaterial({ color: 0x999999, transparent: true, opacity: 0.95 }));
                            smk.position.copy(g.position).add(new THREE.Vector3((Math.random() - 0.5) * 20, Math.random() * 10, (Math.random() - 0.5) * 20));
                            scene.add(smk); effects.push({ m: smk, l: 600, type: 'smoke' });
                        }
                    }
                    scene.remove(g); grenades.splice(i, 1);
                }
            }

            effects.forEach((ef, ei) => {
                if (ef.type === 'lighthouse') { ef.m.userData.update(time); }
                if (ef.type === 'explosion') { ef.m.scale.multiplyScalar(1.08); ef.m.material.opacity *= 0.9; }
                if (ef.type === 'smoke') { ef.m.scale.multiplyScalar(1.002); ef.m.material.opacity *= 0.998; }
                if (ef.l !== undefined && --ef.l <= 0) { scene.remove(ef.m); effects.splice(ei, 1); }
            });

            // MELHORIA NA MIRA: Posi√ß√£o de ADS agora √© a mesma de Hip Fire (Over the shoulder) para evitar obstru√ß√£o pela cabe√ßa
            if (isFPS || (isADS && currentWeapon === 'SNIPER')) {
                charModel.visible = false;
                camera.position.copy(playerGroup.position).add(new THREE.Vector3(0, 3.2, 0));
                camera.rotation.set(cameraPitch, cameraYaw, 0, 'YXZ');
            }
            else {
                charModel.visible = true;
                const dist = isADS ? 10.0 : 16.0;
                const offsetDist = 3.0; // Agora o offset lateral √© constante para n√£o tampar a vis√£o
                const rightDir = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
                const camPos = new THREE.Vector3(Math.sin(cameraYaw) * dist, Math.max(1.0, 5.8 - cameraPitch * 12), Math.cos(cameraYaw) * dist).add(rightDir.multiplyScalar(offsetDist));
                camera.position.copy(playerGroup.position).add(camPos);
                camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0, 3.2, 0)).add(rightDir.multiplyScalar(offsetDist)));
            }

            ray.setFromCamera({ x: 0, y: 0 }, camera);
            const hitWorld = ray.intersectObjects(obstacles);
            const target = hitWorld.length > 0 ? hitWorld[0].point : ray.ray.at(500, new THREE.Vector3());
            charModel.userData.limbs.weapon.lookAt(target);

            if (isShooting) {
                fireFocusTimer += dt;
                const focusThreshold = currentWeapon === 'SNIPER' ? 0.4 : 0.25;

                if (fireFocusTimer > focusThreshold) {
                    if (time - lastShot > (currentWeapon === 'SNIPER' ? 1.4 : 0.14)) {
                        spawnBullet('player', camera.position.clone(), target, 'player');
                        lastShot = time;

                        // Enviar tiro ao servidor multiplayer
                        if (isMultiplayer && socket) {
                            // Verificar se acertou algum jogador remoto
                            let hitPlayerId = null;
                            remotePlayers.forEach((playerData, playerId) => {
                                if (playerData.model) {
                                    const playerBox = new THREE.Box3().setFromCenterAndSize(
                                        playerData.model.position.clone().add(new THREE.Vector3(0, 2.4, 0)),
                                        new THREE.Vector3(3.0, 4.8, 3.0)
                                    );
                                    if (ray.ray.intersectsBox(playerBox)) {
                                        hitPlayerId = playerId;
                                    }
                                }
                            });

                            socket.emit('player-shoot', {
                                from: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                                to: { x: target.x, y: target.y, z: target.z },
                                weaponType: currentWeapon,
                                hitPlayerId: hitPlayerId
                            });
                        }
                    }
                }
            }

            if (isHost || !isMultiplayer) {
                for (let bi = bots.length - 1; bi >= 0; bi--) {
                    const bot = bots[bi];

                    // Se for multiplayer e eu sou o host, broadcast da morte/dano √© feito via update-bots
                    // mas tiros precisam ser processados.

                    bot.position.y += bot.userData.vY;
                    const bRayFloor = new THREE.Raycaster(bot.position.clone().add(new THREE.Vector3(0, 4.0, 0)), new THREE.Vector3(0, -1, 0));
                    const bFloorHits = bRayFloor.intersectObjects(obstacles); const bFloorY = bFloorHits.length > 0 ? bFloorHits[0].point.y : 0;
                    if (bot.position.y > bFloorY) bot.userData.vY -= 0.035 * (dt * 60); else { bot.position.y = bFloorY; bot.userData.vY = 0; }

                    bot.userData.jumpTimer -= dt;
                    if (bot.userData.jumpTimer <= 0 && bot.position.y <= bFloorY + 0.1) {
                        bot.userData.vY = 0.6;
                        bot.userData.jumpTimer = 2 + Math.random() * 3;
                    }

                    const distCenter = Math.hypot(bot.position.x, bot.position.z); const distPlayer = bot.position.distanceTo(playerGroup.position);

                    if (distCenter > zoneRadius - 10) {
                        const moveSafe = new THREE.Vector3(0, 0, 0).sub(bot.position).normalize();
                        bot.position.add(moveSafe.multiplyScalar(0.85 * (dt * 60))); bot.lookAt(0, bot.position.y, 0);
                    } else {
                        let separation = new THREE.Vector3(); for (let other of bots) { if (other === bot) continue; if (bot.position.distanceTo(other.position) < 8.0) separation.add(bot.position.clone().sub(other.position).normalize().multiplyScalar(0.5)); }
                        if (distPlayer < 12.0) separation.add(bot.position.clone().sub(playerGroup.position).normalize().multiplyScalar(0.6));

                        const isUnderFire = bot.userData.hp < bot.userData.maxHP && distPlayer > 50;

                        if ((distPlayer < 40 || bot.userData.isAggressive) && !isUnderFire) {
                            bot.userData.isAggressive = true;
                            if (bot.userData.currentHouse) {
                                bot.userData.currentHouse.botsInside--;
                                bot.userData.currentHouse = null;
                            }
                            const movePlayer = playerGroup.position.clone().sub(bot.position).normalize();
                            const sideDir = new THREE.Vector3(-movePlayer.z, 0, movePlayer.x).multiplyScalar(Math.sin(time * 12) * 0.8);
                            // Escalar movimento composto por DeltaTime
                            const combinedMove = movePlayer.multiplyScalar(0.75).add(sideDir).add(separation);
                            bot.position.add(combinedMove.multiplyScalar(dt * 60));
                            bot.lookAt(playerGroup.position.x, bot.position.y, playerGroup.position.z);
                        } else {
                            if (!bot.userData.currentHouse || isUnderFire) {
                                let targetDest = null; let minDestDist = Infinity;

                                houseData.forEach(h => {
                                    if (h.botsInside < 2) {
                                        const d = bot.position.distanceTo(h.position);
                                        if (d < minDestDist) { minDestDist = d; targetDest = h; }
                                    }
                                });

                                if (!targetDest) {
                                    obstacles.forEach(o => {
                                        if (o.parent?.userData?.isTree) {
                                            const d = bot.position.distanceTo(o.position);
                                            if (d < minDestDist) { minDestDist = d; targetDest = { position: o.position, isTree: true }; }
                                        }
                                    });
                                }

                                if (targetDest) {
                                    const destPos = targetDest.position;
                                    const moveCenter = destPos.clone().sub(bot.position).normalize();
                                    const zigzag = new THREE.Vector3(-moveCenter.z, 0, moveCenter.x).multiplyScalar(Math.sin(time * 10) * 0.5);
                                    // Escalar movimento composto por DeltaTime
                                    const combinedMove = moveCenter.multiplyScalar(0.7).add(zigzag).add(separation);
                                    bot.position.add(combinedMove.multiplyScalar(dt * 60));
                                    bot.lookAt(destPos.x, bot.position.y, destPos.z);

                                    if (minDestDist < 10) {
                                        if (!targetDest.isTree) {
                                            bot.userData.currentHouse = targetDest;
                                            targetDest.botsInside++;
                                            bot.userData.isAggressive = false;
                                        }
                                    }
                                }
                            } else {
                                bot.lookAt(playerGroup.position.x, bot.position.y, playerGroup.position.z);
                                if (separation.length() > 0.1) bot.position.add(separation.multiplyScalar(dt * 60));
                            }
                        }

                        if ((bot.userData.currentHouse && distPlayer < 100) || bot.userData.isAggressive) {
                            const bEye = bot.position.clone().add(new THREE.Vector3(0, 3.2, 0));
                            const tHead = playerGroup.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                            if (!checkPathObstructedBySmoke(bEye, tHead)) {
                                const bRay = new THREE.Raycaster(bEye, tHead.clone().sub(bEye).normalize());
                                const obs = bRay.intersectObjects(obstacles);
                                const wallHit = obs.find(hit => hit.distance < distPlayer && hit.object.userData.isWall);
                                if (!wallHit) {
                                    bot.userData.reactionTimer += dt;
                                    if (bot.userData.reactionTimer > 0.3) {
                                        if (time - bot.userData.lastShot > (4.4 - cfg.diff)) { spawnBullet('bot', bEye, tHead, bot.userData.id, bot.userData.accuracyCharge); bot.userData.lastShot = time; }
                                    }
                                }
                            }
                        }
                    }
                    if (bot.userData.hp <= 0) {
                        if (bot.userData.currentHouse) bot.userData.currentHouse.botsInside--;
                        addKillLog(`ELIMINADO: ${bot.userData.name}`);
                        playerKills++; scene.remove(bot); bots.splice(bi, 1); continue;
                    }

                    // ANIMAR BOT
                    const botMoving = bot.userData.lastPos ? bot.position.distanceTo(bot.userData.lastPos) > 0.01 : false;
                    animateCharacter(bot, {
                        isWalking: botMoving,
                        isJumping: bot.position.y > bFloorY + 0.2,
                        isShooting: time - bot.userData.lastShot < 0.2,
                        speed: 1.0,
                        time: time,
                        jumpVelocity: bot.userData.vY
                    });
                    bot.userData.lastPos = bot.position.clone();

                    updateNPCHealthBar(bot.userData.hBar, (bot.userData.hp / bot.userData.maxHP) * 100);
                }
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i];
                const prevPos = b.position.clone();
                // Mover baseado em DeltaTime: (Vel * dt)
                const moveStep = b.userData.vel.clone().multiplyScalar(dt);
                b.position.add(moveStep);

                const bRay = new THREE.Raycaster(prevPos, b.userData.vel.clone().normalize(), 0, moveStep.length() + 0.5);
                const obsHits = bRay.intersectObjects(obstacles);
                const wallHit = obsHits.find(h => h.object.userData.isWall);
                if (wallHit) { scene.remove(b); bullets.splice(i, 1); continue; }
                let hitted = false;
                for (let bot of bots) {
                    if (b.userData.ownerId === bot.userData.id) continue;
                    const botBox = new THREE.Box3().setFromCenterAndSize(bot.position.clone().add(new THREE.Vector3(0, 2.4, 0)), new THREE.Vector3(3.0, 4.8, 3.0));
                    if (bRay.ray.intersectsBox(botBox)) {
                        const distToBot = b.position.distanceTo(bot.position);
                        const wallCheck = new THREE.Raycaster(prevPos, b.userData.vel.clone().normalize(), 0, distToBot);
                        const blockingWalls = wallCheck.intersectObjects(obstacles).filter(h => h.object.userData.isWall);
                        if (blockingWalls.length === 0) {
                            bot.userData.hp -= (b.userData.owner === 'player' && currentWeapon === 'SNIPER' ? 400 : 50);
                            if (b.userData.owner === 'player') triggerHitmarker();
                            scene.remove(b); bullets.splice(i, 1); hitted = true; break;
                        }
                    }
                }
                if (hitted) continue;
                const pBox = new THREE.Box3().setFromCenterAndSize(playerGroup.position.clone().add(new THREE.Vector3(0, 2.4, 0)), new THREE.Vector3(3.0, 4.8, 3.0));
                if (b.userData.owner !== 'player' && bRay.ray.intersectsBox(pBox)) {
                    const distToPlayer = b.position.distanceTo(playerGroup.position);
                    const wallCheck = new THREE.Raycaster(prevPos, b.userData.vel.clone().normalize(), 0, distToPlayer);
                    const blockingWalls = wallCheck.intersectObjects(obstacles).filter(h => h.object.userData.isWall);
                    if (blockingWalls.length === 0) {
                        const dmg = 6.0; if (armor > 0) armor -= dmg * 1.5; else health -= dmg; lastDamageTime = time; scene.remove(b); bullets.splice(i, 1); continue;
                    }
                }
                b.userData.prevPos.copy(b.position);
                b.userData.life -= dt;
                if (b.userData.life <= 0) { scene.remove(b); bullets.splice(i, 1); }
            }
            if (health <= 0 && isPlaying) showMsg("ELIMINADO", "Voc√™ n√£o resistiu.");
            if (bots.length === 0 && isPlaying && !isMultiplayer) showMsg("BOOYAH!", "O soberano de Cana√£!");

            // Atualizar jogadores remotos (multiplayer)
            updateRemotePlayers();

            updateMinimap(); renderer.render(scene, camera);
        }
        function setupVoiceChatUI() {
            const btnVoice = document.getElementById('btn-voice');
            if (btnVoice) {
                // Remover listeners antigos para evitar duplicidade
                const newBtn = btnVoice.cloneNode(true);
                if (btnVoice.parentNode) btnVoice.parentNode.replaceChild(newBtn, btnVoice);

                const btn = document.getElementById('btn-voice'); // Refer√™ncia ao novo

                btn.onpointerdown = (e) => {
                    e.preventDefault();
                    isPushToTalkActive = true;
                    voiceChat.startTalking();
                    btn.classList.add('active');
                };
                btn.onpointerup = (e) => {
                    e.preventDefault();
                    isPushToTalkActive = false;
                    voiceChat.stopTalking();
                    btn.classList.remove('active');
                };
                // Mute toggle com long press
                let pressTimer;
                btn.onpointerdown = (e) => {
                    e.preventDefault();
                    pressTimer = setTimeout(() => {
                        voiceChat.toggleMute();
                        btn.classList.toggle('muted', voiceChat.isMuted);
                    }, 500);
                    isPushToTalkActive = true;
                    voiceChat.startTalking();
                    btn.classList.add('active');
                };
                btn.onpointerup = (e) => {
                    clearTimeout(pressTimer);
                    isPushToTalkActive = false;
                    voiceChat.stopTalking();
                    btn.classList.remove('active');
                };
            }
        }

        // ============================================
        // CARREGAR MAPAS GLB AO INICIAR
        // ============================================
        // Aguardar scene estar dispon√≠vel e carregar os mapas
        const checkSceneInterval = setInterval(() => {
            if (scene && camera) {
                clearInterval(checkSceneInterval);
                loadExternalModelsMP();
                console.log('üó∫Ô∏è Iniciando carregamento dos 4 mapas GL B...');
            }
        }, 100);

        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });
    </script>
</body>

</html>