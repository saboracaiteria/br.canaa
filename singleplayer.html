<!DOCTYPE html>
<html lang="pt-pt">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, orientation=landscape">
    <title>Residencial Cana√£ - Tactical Survival</title>
    <style>
        :root {
            --ui-primary: #fcee0a;
            --ui-armor: #00d4ff;
            --ui-danger: #ff003c;
            --ui-bg: #050505;
            --ui-cyan: #00f3ff;
            --ui-magenta: #ff003c;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: var(--ui-bg);
            font-family: 'Segoe UI', Roboto, sans-serif;
            touch-action: none;
            user-select: none;
        }

        #game-container {
            position: absolute;
            inset: 0;
            z-index: 1;
            display: none;
            background: #87CEEB;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* CYBERPUNK START SCREEN */
        .overlay-screen {
            position: fixed;
            inset: 0;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0a1a 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 1000;
            text-align: center;
            padding: 20px;
            overflow-y: auto;
        }

        .overlay-screen::before {
            content: "";
            position: absolute;
            inset: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
            z-index: 2;
        }

        .cyber-title {
            font-size: clamp(1.5rem, 6vw, 4rem);
            color: var(--ui-primary);
            font-weight: 900;
            letter-spacing: 5px;
            margin: 0 0 30px 0;
            text-transform: uppercase;
            position: relative;
            text-shadow: 3px 3px 0px var(--ui-magenta);
        }

        .cyber-title::after {
            content: "TACTICAL SURVIVAL";
            position: absolute;
            bottom: -15px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.8rem;
            letter-spacing: 10px;
            color: var(--ui-cyan);
            width: 100%;
        }

        .config-box {
            background: rgba(0, 0, 0, 0.85);
            padding: 30px;
            border: 2px solid var(--ui-cyan);
            clip-path: polygon(0% 0%, 95% 0%, 100% 5%, 100% 100%, 5% 100%, 0% 95%);
            box-shadow: 0 0 30px rgba(0, 243, 255, 0.2);
            width: 90%;
            max-width: 650px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            position: relative;
            backdrop-filter: blur(10px);
            z-index: 5;
        }

        .config-box::before {
            content: "SYSTEM READY";
            position: absolute;
            top: 5px;
            right: 20px;
            font-size: 0.6rem;
            color: var(--ui-cyan);
        }

        .field {
            display: flex;
            flex-direction: column;
            text-align: left;
        }

        .field label {
            font-size: 0.65rem;
            font-weight: bold;
            color: var(--ui-cyan);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .field input,
        .field select {
            padding: 12px;
            border-radius: 0;
            border: none;
            background: #111;
            color: white;
            font-size: 0.9rem;
            border-left: 3px solid var(--ui-magenta);
            outline: none;
            transition: 0.3s;
        }

        .field input:focus {
            background: #222;
            border-left-color: var(--ui-primary);
        }

        input[type="range"] {
            appearance: none;
            height: 4px;
            background: #333;
            margin: 15px 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 15px;
            height: 15px;
            background: var(--ui-primary);
            cursor: pointer;
            border-radius: 0;
        }

        .btn-main {
            grid-column: span 2;
            padding: 18px;
            border: none;
            cursor: pointer;
            transition: 0.3s;
            font-size: 1.1rem;
            text-transform: uppercase;
            font-weight: 900;
            letter-spacing: 2px;
            clip-path: polygon(5% 0%, 100% 0%, 95% 100%, 0% 100%);
        }

        .btn-play {
            background: var(--ui-primary);
            color: #000;
            margin-top: 10px;
        }

        .btn-play:hover {
            background: #fff;
            transform: scale(1.02);
            box-shadow: 0 0 20px var(--ui-primary);
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--ui-magenta);
            color: var(--ui-magenta);
            font-size: 0.8rem;
            padding: 10px;
        }

        .btn-secondary:hover {
            background: var(--ui-magenta);
            color: white;
        }

        .dev-info {
            grid-column: span 2;
            margin-top: 15px;
            font-size: 0.7rem;
            color: rgba(255, 255, 255, 0.6);
            display: flex;
            flex-direction: column;
            gap: 5px;
            align-items: center;
        }

        .dev-info a {
            color: var(--ui-cyan);
            text-decoration: none;
            font-weight: bold;
            transition: 0.3s;
        }

        .dev-info a:hover {
            color: var(--ui-primary);
            text-shadow: 0 0 10px var(--ui-primary);
        }

        @media (orientation: landscape) and (max-height: 500px) {
            .overlay-screen {
                justify-content: flex-start;
                padding: 10px;
            }

            .cyber-title {
                font-size: 1.5rem;
                margin-bottom: 20px;
                letter-spacing: 2px;
            }

            .cyber-title::after {
                font-size: 0.5rem;
                letter-spacing: 4px;
                bottom: -10px;
            }

            .config-box {
                padding: 15px;
                gap: 10px;
                max-width: 95%;
            }

            .field label {
                font-size: 0.55rem;
                margin-bottom: 4px;
            }

            .field input,
            .field select {
                padding: 8px;
                font-size: 0.8rem;
            }

            input[type="range"] {
                margin: 8px 0;
            }

            .btn-main {
                padding: 12px;
                font-size: 0.9rem;
                margin-top: 5px;
            }

            .btn-secondary {
                padding: 6px;
                font-size: 0.7rem;
            }

            .dev-info {
                margin-top: 5px;
                font-size: 0.6rem;
            }
        }

        #hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            z-index: 100;
            display: none;
        }

        .hud-el {
            position: absolute;
            background: rgba(0, 0, 0, 0.3);
            border: 2.5px solid rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            backdrop-filter: blur(8px);
            pointer-events: auto;
            touch-action: none;
            box-sizing: border-box;
            text-align: center;
        }

        .hud-el.dragging {
            border: 3px dashed var(--ui-primary) !important;
            background: rgba(255, 234, 0, 0.4) !important;
            z-index: 5000 !important;
            transform: scale(1.1);
        }

        #minimap-container {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 100px;
            height: 100px;
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid #fff;
            border-radius: 10px;
            overflow: hidden;
            pointer-events: auto;
            z-index: 110;
        }

        #minimap-canvas {
            width: 100%;
            height: 100%;
        }

        /* DOIS BOT√ïES DE TIRO */
        #btn-fire-ads {
            bottom: 40px;
            right: 40px;
            width: 125px;
            height: 125px;
            border-color: var(--ui-danger);
            font-size: 20px;
            background: radial-gradient(circle, rgba(255, 68, 68, 0.3) 0%, rgba(0, 0, 0, 0.2) 70%);
        }

        #btn-fire-hip {
            bottom: 40px;
            right: 180px;
            width: 90px;
            height: 90px;
            border-color: #fff;
            font-size: 14px;
            background: rgba(255, 255, 255, 0.1);
        }

        #btn-ads {
            bottom: 180px;
            right: 55px;
            width: 85px;
            height: 85px;
            font-size: 26px;
        }

        #btn-jump {
            bottom: 140px;
            right: 160px;
            width: 80px;
            height: 80px;
        }

        #btn-run {
            bottom: 40px;
            left: 180px;
            width: 70px;
            height: 70px;
            border-color: var(--ui-primary);
        }

        #btn-run.active {
            background: var(--ui-primary);
            color: #000;
        }

        #btn-nade {
            bottom: 125px;
            left: 180px;
            width: 70px;
            height: 70px;
        }

        #btn-swap-nade {
            bottom: 210px;
            left: 180px;
            width: 75px;
            height: 75px;
            font-size: 9px;
            border-color: var(--ui-armor);
        }

        #btn-switch-weapon {
            bottom: 300px;
            left: 180px;
            width: 75px;
            height: 75px;
            font-size: 9px;
            border-color: #fff;
        }

        #btn-settings {
            top: 15px;
            right: 15px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        #btn-eye {
            top: 15px;
            right: 80px;
            width: 50px;
            height: 50px;
            font-size: 20px;
        }

        #btn-fullscreen {
            top: 80px;
            right: 15px;
            width: 50px;
            height: 50px;
            font-size: 16px;
        }

        #joy-zone {
            bottom: 40px;
            left: 40px;
            width: 130px;
            height: 130px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: rgba(255, 255, 255, 0.05);
        }

        #joy-knob {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            background: #fff;
            border-radius: 50%;
            pointer-events: none;
        }

        #status-wrap {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .bar-outer {
            width: 100%;
            height: 12px;
            background: rgba(0, 0, 0, 0.8);
            border: 1.5px solid rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            overflow: hidden;
        }

        #hp-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #f00, #0f0);
            transition: 0.3s;
        }

        #armor-bar {
            width: 100%;
            height: 100%;
            background: var(--ui-armor);
            transition: 0.3s;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 32px;
            height: 32px;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border: 2px solid rgba(255, 255, 255, 0.4);
            border-radius: 50%;
        }

        #crosshair-dot {
            width: 6px;
            height: 6px;
            background: #ff0000;
            border-radius: 50%;
            box-shadow: 0 0 10px #ff0000, 0 0 2px #fff;
        }

        #hitmarker {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(45deg);
            width: 20px;
            height: 20px;
            pointer-events: none;
            display: none;
            z-index: 101;
        }

        .hm-line {
            position: absolute;
            background: #fff;
            width: 2px;
            height: 8px;
            left: 50%;
            transform: translateX(-50%);
        }

        .hm-2 {
            bottom: 0;
        }

        .hm-3 {
            left: 0;
            top: 50%;
            height: 2px;
            width: 8px;
            transform: translateY(-50%);
        }

        .hm-4 {
            right: 0;
            top: 50%;
            height: 2px;
            width: 8px;
            transform: translateY(-50%);
        }

        #timer-display {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 16px;
            border-radius: 20px;
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            border: 1px solid var(--ui-primary);
        }

        #player-counters {
            position: absolute;
            top: 15px;
            right: 150px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 12px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            border: 1px solid #fff;
            pointer-events: none;
            text-align: left;
        }

        .counter-row {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        .c-alive {
            color: #0f0;
        }

        .c-dead {
            color: #f44;
        }

        .c-kills {
            color: var(--ui-primary);
        }

        #kill-log {
            position: absolute;
            top: 70px;
            left: 15px;
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
        }

        .kill-entry {
            background: rgba(0, 0, 0, 0.4);
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 4px;
            border-left: 3px solid var(--ui-danger);
            animation: slideIn 0.3s ease-out;
        }

        #game-msg {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 40px;
            border-radius: 20px;
            border: 2px solid var(--ui-primary);
            text-align: center;
            display: none;
            z-index: 3000;
        }

        #save-hud-btn {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #28a745;
            color: white;
            padding: 15px 50px;
            border-radius: 12px;
            font-weight: bold;
            z-index: 6000;
            display: none;
            border: 3px solid white;
            cursor: pointer;
        }

        .hidden {
            display: none !important;
        }

        /* NOVA MIRA SNIPER */
        #sniper-scope {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle, transparent 30%, black 70%);
            pointer-events: none;
            display: none;
            z-index: 2000;
        }

        #sniper-scope::before,
        #sniper-scope::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #00ff00;
        }

        #sniper-scope::before {
            width: 100vw;
            height: 1px;
            opacity: 0.5;
        }

        #sniper-scope::after {
            width: 1px;
            height: 100vh;
            opacity: 0.5;
        }

        #sniper-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            border: 2px solid rgba(0, 255, 0, 0.3);
            border-radius: 50%;
        }
    </style>
</head>

<body onload="loadConfigs()">

    <div id="game-container"></div>
    <div id="sniper-scope">
        <div id="sniper-center"></div>
    </div>

    <div id="game-msg">
        <h2 id="msg-title"></h2>
        <p id="msg-body"></p>
        <button class="btn-main btn-play" onclick="location.reload()">RECOME√áAR</button>
    </div>

    <button id="save-hud-btn" onclick="toggleHudEdit()">üíæ SALVAR HUD</button>

    <div id="start-screen" class="overlay-screen">
        <div class="cyber-title">RESIDENCIAL CANA√É</div>
        <div class="config-box">
            <div class="field">
                <label>// N¬∫ SOLDADOS</label>
                <input type="number" id="bot-count" value="20" min="1" max="60">
            </div>
            <div class="field">
                <label>// DIFICULDADE</label>
                <select id="bot-diff">
                    <option value="1">Casual</option>
                    <option value="2" selected>Normal</option>
                    <option value="3">Veterano</option>
                </select>
            </div>
            <div class="field">
                <label>// SENSIBILIDADE [<span id="val-sens-start">55</span>]</label>
                <input type="range" id="cfg-sens" min="1" max="100" value="55"
                    oninput="document.getElementById('val-sens-start').innerText=this.value">
            </div>
            <div class="field">
                <label>// FOV [<span id="val-fov-start">75</span>]</label>
                <input type="range" id="cfg-fov" min="40" max="100" value="75"
                    oninput="document.getElementById('val-fov-start').innerText=this.value">
            </div>
            <button class="btn-main btn-secondary" onclick="toggleHudEdit()">‚úèÔ∏è CUSTOMIZAR INTERFACE (HUD)</button>
            <button class="btn-main btn-play" onclick="initGame()">[ INICIAR PROTOCOLO ]</button>

            <div class="dev-info">
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">// DEVELOPER: _nildoxz</a>
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">Cana√£ dos Caraj√°s - 2026</a>
            </div>
        </div>
    </div>

    <div id="pause-menu" class="overlay-screen hidden">
        <div class="cyber-title">PAUSA</div>
        <div class="config-box">
            <div class="field"><label>// SENSIBILIDADE</label><input type="range" id="menu-sens" min="1" max="100"
                    value="55" oninput="updateLiveSettings('sens', this.value)"></div>
            <div class="field"><label>// FOV</label><input type="range" id="menu-fov" min="40" max="100" value="75"
                    oninput="updateLiveSettings('fov', this.value)"></div>
            <button class="btn-main btn-secondary" onclick="toggleHudEdit()">‚úèÔ∏è REPOSICIONAR BOT√ïES</button>
            <button class="btn-main btn-play" onclick="togglePauseMenu()">CONTINUAR OPERA√á√ÉO</button>
            <button class="btn-main" style="background: var(--ui-danger); color: #fff; margin-top: 10px;"
                onclick="location.reload()">ABORTAR</button>

            <div class="dev-info">
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">// DEVELOPER: _nildoxz</a>
                <a href="https://www.instagram.com/_nildoxz/" target="_blank">Cana√£ dos Caraj√°s - 2026</a>
            </div>
        </div>
    </div>

    <div id="hud">
        <div id="timer-display">ZONA: 100s</div>

        <div id="player-counters">
            <div class="counter-row"><span>VIVOS:</span> <span id="count-alive" class="c-alive">0</span></div>
            <div class="counter-row"><span>MORTOS:</span> <span id="count-dead" class="c-dead">0</span></div>
            <div class="counter-row"><span>ABATES:</span> <span id="count-kills" class="c-kills">0</span></div>
        </div>

        <div id="kill-log"></div>
        <div id="crosshair">
            <div id="crosshair-dot"></div>
        </div>
        <div id="hitmarker">
            <div class="hm-line hm-1"></div>
            <div class="hm-line hm-2"></div>
            <div class="hm-line hm-3"></div>
            <div class="hm-line hm-4"></div>
        </div>

        <div id="status-wrap">
            <div class="bar-outer">
                <div id="armor-bar"></div>
            </div>
            <div class="bar-outer">
                <div id="hp-bar"></div>
            </div>
        </div>

        <div id="btn-settings" class="hud-el">‚öôÔ∏è</div>
        <div id="btn-eye" class="hud-el">üëÅÔ∏è</div>
        <div id="btn-fire-ads" class="hud-el">TIRO<br>ADS</div>
        <div id="btn-fire-hip" class="hud-el">TIRO<br>HIP</div>
        <div id="btn-ads" class="hud-el">üéØ</div>
        <div id="btn-jump" class="hud-el">PULAR</div>
        <div id="btn-run" class="hud-el">üèÉ</div>
        <div id="btn-nade" class="hud-el">üí£</div>
        <div id="btn-swap-nade" class="hud-el">BOMBA<br>(EXPL)</div>
        <div id="btn-switch-weapon" class="hud-el">ARMA<br>(FUZIL)</div>
        <div id="btn-fullscreen" class="hud-el" onclick="toggleFullscreen()">‚õ∂</div>
        <div id="joy-zone" class="hud-el">
            <div id="joy-knob"></div>
        </div>
        <div id="minimap-container" class="hud-el"><canvas id="minimap-canvas"></canvas></div>
    </div>

    <script
        type="importmap"> { "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js", "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/" } } </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let scene, camera, renderer, clock, playerGroup, charModel, zoneMesh, sunObj;
        let cameraYaw = 0, cameraPitch = 0, vY = 0, jumps = 0;
        let isPlaying = false, isPaused = false, isRunning = false, isADS = false, isShooting = false, isFPS = false;
        let fireFocusTimer = 0;
        let currentWeapon = 'AR', grenadeType = 'explosive';
        let bullets = [], bots = [], obstacles = [], obstacleBoxes = [], grenades = [], effects = [], medkits = [];
        let health = 100, armor = 100, lastShot = 0, lastDamageTime = 0, playerKills = 0;
        let zoneTimer = 100, zoneRadius = 500, zoneActive = false;
        let initialBotCount = 20, houseData = [];
        let gasPauseCount = 0, gasPauseTimer = 0;

        // DELTA TIME E CONSTANTES DE F√çSICA (em unidades/segundo)
        let deltaTime = 0;
        const GRAVITY = 1.5; // Gravidade em unidades/segundo¬≤
        const PLAYER_SPEED_WALK = 48; // Velocidade de caminhada
        const PLAYER_SPEED_RUN = 57; // Velocidade de corrida
        const PLAYER_SPEED_ADS = 19; // Velocidade em ADS
        const JUMP_VELOCITY = 48; // Velocidade inicial do pulo
        const BOT_SPEED = 42; // Velocidade dos bots
        const BOT_GRAVITY = 2.1; // Gravidade dos bots
        const ZONE_SHRINK_RATE = 7.2; // Taxa de encolhimento da zona por segundo
        const ARMOR_REGEN_RATE = 9; // Regenera√ß√£o de armadura por segundo
        const GRENADE_LIFE_TIME = 2.0; // Tempo de vida da granada em segundos
        const ZONE_DAMAGE_RATE = 3.0; // Dano da zona por segundo

        const ray = new THREE.Raycaster();
        const keys = {};

        let minimapCtx, minimapCanvas;
        let moveVec = new THREE.Vector2(), moveTouchId = null, lookTouchId = null, fireTouchId = null;
        let lastX = 0, lastY = 0, fireLastX = 0, fireLastY = 0;
        let isEditingHud = false, cfg = { bots: 20, diff: 2, sens: 0.0165, fov: 75 };

        const bulletGeo = new THREE.SphereGeometry(0.45, 8, 8);
        const bulletMatYellow = new THREE.MeshBasicMaterial({ color: 0xffff00 });

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain); gain.connect(audioCtx.destination);
            if (type === 'shoot') {
                osc.type = 'square'; osc.frequency.setValueAtTime(160, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.08, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                osc.start(); osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'sniper') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(200, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
                osc.start(); osc.stop(audioCtx.currentTime + 0.3);
            } else if (type === 'exp') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(20, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1, audioCtx.currentTime + 2.0);
                gain.gain.setValueAtTime(1.0, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 2.0);
                osc.start(); osc.stop(audioCtx.currentTime + 2.0);
            } else if (type === 'hit') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(1000, audioCtx.currentTime);
                gain.gain.setValueAtTime(0.1, audioCtx.currentTime); gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.05);
                osc.start(); osc.stop(audioCtx.currentTime + 0.05);
            }
        }

        window.toggleFullscreen = () => { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => { }); else if (document.exitFullscreen) document.exitFullscreen(); };

        document.addEventListener('touchstart', function forceFS() {
            if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => { });
            document.removeEventListener('touchstart', forceFS);
        }, { once: true });

        window.updateLiveSettings = (type, val) => { if (type === 'sens') cfg.sens = parseFloat(val) * 0.0003; if (type === 'fov') { cfg.fov = parseInt(val); if (camera && !isADS) { camera.fov = cfg.fov; camera.updateProjectionMatrix(); } } };
        window.togglePauseMenu = () => { if (isPlaying) { isPaused = !isPaused; document.getElementById('pause-menu').classList.toggle('hidden', !isPaused); } };

        window.toggleHudEdit = () => {
            isEditingHud = !isEditingHud;
            const hudEls = document.querySelectorAll('.hud-el');
            const saveBtn = document.getElementById('save-hud-btn');
            const startScreen = document.getElementById('start-screen');
            const pauseMenu = document.getElementById('pause-menu');
            const hudContainer = document.getElementById('hud');

            if (isEditingHud) {
                startScreen.classList.add('hidden'); pauseMenu.classList.add('hidden');
                hudContainer.style.display = 'block'; hudContainer.style.pointerEvents = 'auto'; saveBtn.style.display = 'block';
                hudEls.forEach(el => { el.classList.add('dragging'); el.addEventListener('touchstart', onHudTouchStart, { passive: false }); });
            } else {
                hudContainer.style.pointerEvents = 'none'; saveBtn.style.display = 'none';
                if (!isPlaying) startScreen.classList.remove('hidden'); else if (isPaused) pauseMenu.classList.remove('hidden');
                hudEls.forEach(el => { el.classList.remove('dragging'); el.removeEventListener('touchstart', onHudTouchStart); });
                saveHudPositions();
            }
        };

        function onHudTouchStart(e) {
            if (!isEditingHud) return;
            const item = e.currentTarget; const touch = e.touches[0]; const rect = item.getBoundingClientRect();
            const offsetX = touch.clientX - rect.left; const offsetY = touch.clientY - rect.top;
            const moveHandler = (moveEvent) => { moveEvent.preventDefault(); const t = moveEvent.touches[0]; item.style.bottom = 'auto'; item.style.right = 'auto'; item.style.left = (t.clientX - offsetX) + 'px'; item.style.top = (t.clientY - offsetY) + 'px'; };
            const endHandler = () => { window.removeEventListener('touchmove', moveHandler); window.removeEventListener('touchend', endHandler); };
            window.addEventListener('touchmove', moveHandler, { passive: false }); window.addEventListener('touchend', endHandler);
        }

        function saveHudPositions() {
            const data = {}; document.querySelectorAll('.hud-el').forEach(el => { data[el.id] = { left: el.style.left, top: el.style.top }; });
            localStorage.setItem('canaa_hud_v3', JSON.stringify(data));
        }

        function saveGeneralConfigs() {
            const gc = {
                bots: document.getElementById('bot-count').value,
                diff: document.getElementById('bot-diff').value,
                sens: document.getElementById('cfg-sens').value,
                fov: document.getElementById('cfg-fov').value
            };
            localStorage.setItem('canaa_config_v1', JSON.stringify(gc));
        }

        window.loadConfigs = function () {
            // Primeiro, verifica par√¢metros da URL
            const urlParams = new URLSearchParams(window.location.search);

            // Carregar HUD salvo
            const savedHud = localStorage.getItem('canaa_hud_v3');
            if (savedHud) {
                const data = JSON.parse(savedHud);
                for (let id in data) {
                    const el = document.getElementById(id);
                    if (el && data[id].left && data[id].top) { el.style.bottom = 'auto'; el.style.right = 'auto'; el.style.left = data[id].left; el.style.top = data[id].top; }
                }
            }

            // Aplicar configura√ß√µes da URL ou localStorage
            const botCount = urlParams.get('botCount') || (localStorage.getItem('canaa_config_v1') ? JSON.parse(localStorage.getItem('canaa_config_v1')).bots : '20');
            const botDiff = urlParams.get('botDiff') || (localStorage.getItem('canaa_config_v1') ? JSON.parse(localStorage.getItem('canaa_config_v1')).diff : '2');
            const sens = urlParams.get('sens') || (localStorage.getItem('canaa_config_v1') ? JSON.parse(localStorage.getItem('canaa_config_v1')).sens : '55');
            const fov = urlParams.get('fov') || (localStorage.getItem('canaa_config_v1') ? JSON.parse(localStorage.getItem('canaa_config_v1')).fov : '75');
            const playerName = urlParams.get('playerName') || localStorage.getItem('playerName') || 'Guerreiro';

            document.getElementById('bot-count').value = botCount;
            document.getElementById('bot-diff').value = botDiff;
            document.getElementById('cfg-sens').value = sens;
            document.getElementById('cfg-fov').value = fov;
            document.getElementById('val-sens-start').innerText = sens;
            document.getElementById('val-fov-start').innerText = fov;

            // Exibir nome do jogador
            localStorage.setItem('playerName', playerName);

            // Se veio direto da URL, iniciar imediatamente
            if (urlParams.get('botCount')) {
                setTimeout(() => initGame(), 500);
            }
        };

        function triggerHitmarker() { const hm = document.getElementById('hitmarker'); hm.style.display = 'block'; playSfx('hit'); setTimeout(() => hm.style.display = 'none', 100); }
        function addKillLog(msg) { const log = document.getElementById('kill-log'); const entry = document.createElement('div'); entry.className = 'kill-entry'; entry.innerText = msg; log.appendChild(entry); setTimeout(() => entry.remove(), 4000); }

        window.initGame = () => {
            saveGeneralConfigs();
            toggleFullscreen();
            initialBotCount = parseInt(document.getElementById('bot-count').value);
            cfg.bots = initialBotCount;
            cfg.diff = parseInt(document.getElementById('bot-diff').value);
            cfg.sens = parseInt(document.getElementById('cfg-sens').value) * 0.0003;
            cfg.fov = parseInt(document.getElementById('cfg-fov').value);
            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('game-container').style.display = 'block';
            document.getElementById('hud').style.display = 'block';
            setupThree(); setupMinimap(); isPlaying = true; startZoneTimer();
        };

        function showMsg(title, body) { isPlaying = false; const panel = document.getElementById('game-msg'); document.getElementById('msg-title').innerText = title; document.getElementById('msg-body').innerText = body; panel.style.display = 'block'; }

        function setupMinimap() { minimapCanvas = document.getElementById('minimap-canvas'); minimapCanvas.width = 100; minimapCanvas.height = 100; minimapCtx = minimapCanvas.getContext('2d'); }
        function updateMinimap() {
            if (!minimapCtx) return;
            const ctx = minimapCtx; const w = 100, h = 100, mapScale = 0.12;
            ctx.clearRect(0, 0, w, h); ctx.fillStyle = "rgba(10, 20, 40, 0.8)"; ctx.fillRect(0, 0, w, h);
            const cx = w / 2, cz = h / 2;
            ctx.strokeStyle = "rgba(255, 234, 0, 0.5)"; ctx.lineWidth = 2; ctx.beginPath();
            ctx.arc(cx, cz, zoneRadius * mapScale, 0, Math.PI * 2); ctx.stroke();
            ctx.fillStyle = "#ff4444";
            bots.forEach(bot => {
                const bx = cx + (bot.position.x - playerGroup.position.x) * mapScale;
                const bz = cz + (bot.position.z - playerGroup.position.z) * mapScale;
                if (bx > 0 && bx < w && bz > 0 && bz < h) { ctx.beginPath(); ctx.arc(bx, bz, 2.5, 0, Math.PI * 2); ctx.fill(); }
            });
            ctx.fillStyle = "#00ff00"; ctx.beginPath(); ctx.arc(cx, cz, 3.5, 0, Math.PI * 2); ctx.fill();
        }

        function createNPCHealthBar() {
            const canvas = document.createElement('canvas'); canvas.width = 64; canvas.height = 8;
            const texture = new THREE.CanvasTexture(canvas);
            const material = new THREE.SpriteMaterial({ map: texture, depthTest: false });
            const sprite = new THREE.Sprite(material); sprite.scale.set(3.0, 0.4, 1); sprite.position.y = 4.8;
            sprite.userData = { canvas, texture }; return sprite;
        }
        function updateNPCHealthBar(sprite, hp) { const { canvas, texture } = sprite.userData; const ctx = canvas.getContext('2d'); ctx.clearRect(0, 0, 64, 8); ctx.fillStyle = hp > 50 ? '#0f0' : hp > 20 ? '#ff0' : '#f00'; ctx.fillRect(0, 0, (hp / 100) * 64, 8); texture.needsUpdate = true; }

        function createHumanoid(color, id) {
            const group = new THREE.Group();
            const mB = new THREE.MeshStandardMaterial({ color: color, roughness: 0.7 });
            const mS = new THREE.MeshStandardMaterial({ color: 0xffdbac });

            // Propor√ß√µes mais realistas (altura total ~4 unidades antes do scale)
            // Torso: mais alongado e estreito
            const torso = new THREE.Mesh(new THREE.BoxGeometry(0.5, 1.2, 0.35), mB);
            torso.position.y = 1.1; // Centro do torso

            // Cabe√ßa: propor√ß√£o 1/7 da altura total (~0.57 unidades)
            const head = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), mS);
            head.position.y = 1.9; // Topo do torso + metade da cabe√ßa

            // Capacete
            const helmet = new THREE.Mesh(
                new THREE.BoxGeometry(0.45, 0.22, 0.45),
                new THREE.MeshStandardMaterial({ color: 0x222222 })
            );
            helmet.position.y = 0.15;
            head.add(helmet);

            // Pernas: mais compridas (~50% da altura total, divididas em coxa e canela)
            const lThigh = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.6, 0.22), mB);
            lThigh.position.set(-0.15, 0.35, 0);
            const rThigh = new THREE.Mesh(new THREE.BoxGeometry(0.22, 0.6, 0.22), mB);
            rThigh.position.set(0.15, 0.35, 0);

            // Canelas (parte inferior da perna)
            const lShin = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.2), mB);
            lShin.position.set(-0.15, -0.25, 0);
            const rShin = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.6, 0.2), mB);
            rShin.position.set(0.15, -0.25, 0);

            // Bra√ßos: mais compridos e finos, divididos em bra√ßo superior e antebra√ßo
            const lUpperArm = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.55, 0.18), mB);
            lUpperArm.position.set(-0.38, 1.25, 0);
            const rUpperArm = new THREE.Mesh(new THREE.BoxGeometry(0.18, 0.55, 0.18), mB);
            rUpperArm.position.set(0.38, 1.25, 0);

            // Antebra√ßos
            const lForearm = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.5, 0.16), mB);
            lForearm.position.set(-0.38, 0.7, 0);
            const rForearm = new THREE.Mesh(new THREE.BoxGeometry(0.16, 0.5, 0.16), mB);
            rForearm.position.set(0.38, 0.7, 0);

            // Arma: rifle mais detalhado
            const weapon = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.15, 1.0),
                new THREE.MeshStandardMaterial({ color: 0x111111 })
            );
            weapon.position.set(0.38, 0.7, -0.45);

            group.add(torso, head, lThigh, rThigh, lShin, rShin, lUpperArm, rUpperArm, lForearm, rForearm, weapon);

            // Armazenar limbs para anima√ß√£o
            group.userData = {
                limbs: {
                    lLeg: lThigh, // Usar coxa para anima√ß√£o de caminhada (rota√ß√£o)
                    rLeg: rThigh,
                    lArm: lUpperArm, // Usar bra√ßo superior para anima√ß√£o
                    rArm: rUpperArm,
                    weapon
                },
                hp: 100,
                id: id || Math.random(),
                vY: 0
            };

            group.scale.set(2, 2, 2); // Escala final
            return group;
        }

        function setupThree() {
            scene = new THREE.Scene(); scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.FogExp2(0x87CEEB, 0.0006);
            clock = new THREE.Clock();
            camera = new THREE.PerspectiveCamera(cfg.fov, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            renderer.shadowMap.enabled = true;
            document.getElementById('game-container').appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const sunLight = new THREE.DirectionalLight(0xffffff, 1.1); sunLight.position.set(300, 500, 100); sunLight.castShadow = true;
            sunLight.shadow.camera.left = -800; sunLight.shadow.camera.right = 800; sunLight.shadow.camera.top = 800; sunLight.shadow.camera.bottom = -800;
            sunLight.shadow.mapSize.width = 2048; sunLight.shadow.mapSize.height = 2048; scene.add(sunLight);
            sunObj = new THREE.Mesh(new THREE.SphereGeometry(25, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffff00 })); sunObj.position.set(400, 600, 200); scene.add(sunObj);

            createWorld();

            // Carregar modelos 3D externos (poly.pizza, etc)
            loadExternalModels();

            playerGroup = new THREE.Group(); charModel = createHumanoid(0x2E7D32, 'player'); playerGroup.add(charModel); scene.add(playerGroup);
            playerGroup.position.set(30, 2, 0);

            zoneMesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 1500, 64, 1, true), new THREE.MeshBasicMaterial({ color: 0x00d4ff, transparent: true, opacity: 0.2, side: THREE.DoubleSide }));
            zoneMesh.scale.set(zoneRadius, 1, zoneRadius); zoneMesh.position.y = 750; scene.add(zoneMesh);

            setupBotsPeriphery();
            setupGameInput();
            scene.updateMatrixWorld(true);
            updateCollisionBoxes();
            animate();
        }

        function updateCollisionBoxes() {
            obstacleBoxes = [];
            obstacles.forEach(o => {
                if (o.geometry && o.userData.isSolid !== false && !o.userData.isGround) {
                    const b = new THREE.Box3().setFromObject(o);
                    b.userData = o.userData;
                    obstacleBoxes.push(b);
                }
            });
        }

        function createTree(x, z) {
            const group = new THREE.Group();
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.2, 12, 8), new THREE.MeshStandardMaterial({ color: 0x5D4037 }));
            trunk.position.y = 6;
            trunk.userData.isWall = true; // Tronco √© s√≥lido
            const leaves = new THREE.Mesh(new THREE.ConeGeometry(6, 16, 8), new THREE.MeshStandardMaterial({ color: 0x2E7D32, roughness: 0.8 }));
            leaves.position.y = 16;
            leaves.userData.isSolid = false; // Folhas n√£o s√£o s√≥lidas (player pode passar)
            group.add(trunk, leaves);
            group.position.set(x, 0, z);
            group.userData.isTree = true;
            scene.add(group);
            obstacles.push(trunk); // Apenas o tronco √© obst√°culo
        }

        function createLighthouse(x, z) {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(8, 12, 60, 16), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
            base.position.y = 30;
            const top = new THREE.Mesh(new THREE.CylinderGeometry(10, 8, 8, 16), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            top.position.y = 64;
            const glass = new THREE.Mesh(new THREE.CylinderGeometry(6, 6, 8, 16), new THREE.MeshBasicMaterial({ color: 0xffff00, transparent: true, opacity: 0.6 }));
            glass.position.y = 72;
            const dome = new THREE.Mesh(new THREE.SphereGeometry(7, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2), new THREE.MeshStandardMaterial({ color: 0x333333 }));
            dome.position.y = 76;

            const spot = new THREE.SpotLight(0xffffff, 5, 400, Math.PI / 6, 0.5);
            spot.position.set(0, 72, 0);
            spot.target.position.set(100, 0, 0);
            group.add(base, top, glass, dome, spot, spot.target);
            group.position.set(x, 0, z);
            scene.add(group);
            obstacles.push(base, top, dome);

            group.userData.update = (t) => {
                spot.target.position.x = Math.cos(t) * 100;
                spot.target.position.z = Math.sin(t) * 100;
            };
            effects.push({ m: group, type: 'lighthouse' });
        }

        function createDetailedHouse(x, z) {
            const group = new THREE.Group();
            const wallMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.8 });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x8d4925 });
            const winMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.8 });
            const doorMat = new THREE.MeshStandardMaterial({ color: 0x4d2911 });
            const h = 10, s = 24, t = 1.0;

            const walls = [
                { size: [t, h, s], pos: [-s / 2, h / 2, 0] }, { size: [t, h, s], pos: [s / 2, h / 2, 0] }, { size: [s, h, t], pos: [0, h / 2, -s / 2] },
                { size: [8, h, t], pos: [-s / 2 + 4, h / 2, s / 2] }, { size: [6, h, t], pos: [s / 2 - 3, h / 2, s / 2] }
            ];
            walls.forEach(w => {
                const m = new THREE.Mesh(new THREE.BoxGeometry(...w.size), wallMat);
                m.position.set(...w.pos);
                m.castShadow = true; m.receiveShadow = true;
                m.userData.isWall = true;
                group.add(m); obstacles.push(m);
            });

            const roof = new THREE.Mesh(new THREE.ConeGeometry(s * 0.85, 8, 4), roofMat);
            roof.position.y = h + 4;
            roof.rotation.y = Math.PI / 4;
            roof.userData.isSolid = false; // Teto n√£o tem colis√£o (evita parede invis√≠vel acima)
            group.add(roof); // N√£o adicionar √† lista de obstacles

            const door = new THREE.Mesh(new THREE.BoxGeometry(3.5, 6.5, 0.3), doorMat); door.position.set(-s / 4, 3.25, s / 2 + 0.1); door.userData.isDoor = true; group.add(door);

            const createWin = (px, py, pz, rotY) => {
                const w = new THREE.Mesh(new THREE.BoxGeometry(4.5, 4.5, 0.4), winMat);
                w.position.set(px, py, pz);
                if (rotY) w.rotation.y = rotY;
                group.add(w);
            };
            createWin(s / 4, 6, s / 2 + 0.1, 0);
            createWin(s / 2 + 0.1, 6, 0, Math.PI / 2);
            createWin(-s / 2 - 0.1, 6, 0, -Math.PI / 2);

            const mk = new THREE.Group();
            const mkBox = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.2, 1.2), new THREE.MeshStandardMaterial({ color: 0xffffff }));
            const mkCrossH = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.3, 0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            const mkCrossV = new THREE.Mesh(new THREE.BoxGeometry(0.3, 1.0, 0.1), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
            mkCrossH.position.z = 0.61; mkCrossV.position.z = 0.61; mk.add(mkBox, mkCrossH, mkCrossV);
            mk.position.set(0, 1, 0); mk.userData.isMedkit = true; group.add(mk); medkits.push(mk);

            group.position.set(x, 0, z);
            group.userData.isHouse = true;
            scene.add(group);
            houseData.push({ position: new THREE.Vector3(x, 2, z), botsInside: 0, botsAssigned: [] });
        }

        function createMountains() {
            const mountainMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 1 });
            for (let i = 0; i < 48; i++) {
                const angle = (i / 48) * Math.PI * 2;
                const dist = 1000 + Math.random() * 400;
                const x = Math.cos(angle) * dist;
                const z = Math.sin(angle) * dist;
                const height = 180 + Math.random() * 250;
                const width = 250 + Math.random() * 300;
                const mountain = new THREE.Mesh(new THREE.ConeGeometry(width, height, 4), mountainMat);
                mountain.position.set(x, height / 2 - 5, z);
                mountain.rotation.y = Math.random() * Math.PI;
                scene.add(mountain);
                obstacles.push(mountain);
            }
        }

        function createWorld() {
            // MUNDO ANTIGO REMOVIDO - USANDO APENAS MAPA GLB
            // Todo o cen√°rio (ch√£o, montanhas, √°rvores, etc) vem do arquivo GLB
        }

        // ============================================
        // SISTEMA DE CARREGAMENTO DE MODELOS 3D
        // ============================================
        function loadExternalModels() {
            const loader = new GLTFLoader();

            // CARREGAR MAPA: fps canaa Map.glb
            loader.load(
                'models/fps canaa Map.glb', // Caminho do arquivo GLB
                function (gltf) {
                    // Sucesso - modelo carregado
                    const model = gltf.scene;

                    // Posicionar no centro do mundo
                    model.position.set(0, 0, 0);

                    // Escala inicial (ajuste se necess√°rio)
                    model.scale.set(10, 10, 10);

                    // Adicionar √† cena
                    scene.add(model);

                    // Configurar sombras e colis√µes
                    model.traverse((child) => {
                        if (child.isMesh) {
                            // Ativar sombras
                            child.castShadow = true;
                            child.receiveShadow = true;

                            // Adicionar colis√µes (exceto objetos decorativos)
                            if (!child.name.toLowerCase().includes('decoration')) {
                                child.userData.isWall = true;
                                obstacles.push(child);
                            }
                        }
                    });

                    // Atualizar collision boxes
                    updateCollisionBoxes();

                    console.log('‚úÖ Mapa GLB carregado com sucesso: fps canaa Map.glb');
                },
                function (xhr) {
                    // Progresso do carregamento
                    const percent = (xhr.loaded / xhr.total * 100).toFixed(0);
                    console.log(`üì¶ Carregando mapa GLB: ${percent}%`);
                },
                function (error) {
                    // Erro ao carregar
                    console.error('‚ùå Erro ao carregar mapa GLB:', error);
                    console.error('Verifique se o arquivo "fps canaa Map.glb" est√° na pasta models/');
                }
            );

            // EXEMPLO: Carregar pr√©dio
            /*
            loader.load('models/building.glb', (gltf) => {
                const building = gltf.scene;
                building.position.set(-200, 0, -200);
                building.scale.set(5, 5, 5);
                scene.add(building);
                
                // Colis√µes
                building.traverse((child) => {
                    if (child.isMesh) {
                        child.userData.isWall = true;
                        obstacles.push(child);
                    }
                });
                updateCollisionBoxes();
            });
            */

            console.log('üí° Sistema de modelos 3D pronto. Descomente os exemplos acima para usar.');
        }

        function setupBotsPeriphery() {
            const botHP = [125, 225, 375][cfg.diff - 1];
            for (let i = 0; i < initialBotCount; i++) {
                const bot = createHumanoid(0x7f1d1d, `bot_${i}`);
                const angle = Math.random() * Math.PI * 2;
                const spawnRadius = 850;
                bot.position.set(Math.cos(angle) * spawnRadius, 0, Math.sin(angle) * spawnRadius);
                bot.userData.isAggressive = Math.random() < 0.3;
                bot.userData.willShootOutside = Math.random() < 0.5;
                bot.userData.currentHouse = null;
                bot.userData.hp = botHP; bot.userData.maxHP = botHP; bot.userData.lastShot = 0; bot.userData.name = `Soldado ${i + 1}`;
                bot.userData.reactionTimer = 0; bot.userData.strafeDir = Math.random() > 0.5 ? 1 : -1;
                bot.userData.strafeTimer = 0; bot.userData.accuracyCharge = 0;
                bot.userData.isSeekingCover = false;
                bot.userData.jumpTimer = Math.random() * 5;
                const hb = createNPCHealthBar(); bot.add(hb); bot.userData.hBar = hb; updateNPCHealthBar(hb, 100);
                scene.add(bot); bots.push(bot);
            }
        }

        function setupGameInput() {
            window.addEventListener('keydown', e => keys[e.code] = true); window.addEventListener('keyup', e => keys[e.code] = false);
            window.addEventListener('touchstart', e => {
                if (isEditingHud || isPaused) return;
                for (let t of e.changedTouches) {
                    if (t.clientX < window.innerWidth / 2.5) moveTouchId = t.identifier;
                    else if (t.target.id === 'btn-fire-ads') {
                        fireTouchId = t.identifier;
                        fireLastX = t.clientX;
                        fireLastY = t.clientY;
                        isShooting = true;
                        isADS = true;
                        fireFocusTimer = 0;
                        camera.fov = currentWeapon === 'SNIPER' ? 12 : 30;
                        camera.updateProjectionMatrix();
                        if (currentWeapon === 'SNIPER') document.getElementById('sniper-scope').style.display = 'block';
                    }
                    else if (t.target.id === 'btn-fire-hip') {
                        fireTouchId = t.identifier;
                        fireLastX = t.clientX;
                        fireLastY = t.clientY;
                        isShooting = true;
                        isADS = false; // Disparo normal (curta dist√¢ncia)
                        fireFocusTimer = 10; // For√ßa disparo imediato
                        camera.fov = cfg.fov;
                        camera.updateProjectionMatrix();
                    }
                    else if (!t.target.classList.contains('hud-el')) { lookTouchId = t.identifier; lastX = t.clientX; lastY = t.clientY; }
                }
            });
            window.addEventListener('touchmove', e => {
                if (isEditingHud || isPaused) return;
                for (let t of e.changedTouches) {
                    if (t.identifier === moveTouchId) {
                        const r = document.getElementById('joy-zone').getBoundingClientRect();
                        let dx = t.clientX - (r.left + r.width / 2), dy = t.clientY - (r.top + r.height / 2);
                        const d = Math.hypot(dx, dy); if (d > 65) { dx *= 65 / d; dy *= 65 / d; }
                        document.getElementById('joy-knob').style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
                        moveVec.set(dx / 65, -dy / 65);
                    }
                    if (t.identifier === fireTouchId) {
                        cameraYaw -= (t.clientX - fireLastX) * cfg.sens * 0.8;
                        cameraPitch = Math.max(-0.7, Math.min(1.2, cameraPitch - (t.clientY - fireLastY) * cfg.sens * 1.2));
                        fireLastX = t.clientX; fireLastY = t.clientY;
                    }
                    if (t.identifier === lookTouchId) {
                        cameraYaw -= (t.clientX - lastX) * cfg.sens;
                        cameraPitch = Math.max(-0.7, Math.min(1.2, cameraPitch - (t.clientY - lastY) * cfg.sens));
                        lastX = t.clientX; lastY = t.clientY;
                    }
                }
            }, { passive: false });
            window.addEventListener('touchend', e => {
                for (let t of e.changedTouches) {
                    if (t.identifier === moveTouchId) { moveTouchId = null; moveVec.set(0, 0); document.getElementById('joy-knob').style.transform = 'translate(-50%, -50%)'; }
                    if (t.identifier === lookTouchId) lookTouchId = null;
                    if (t.identifier === fireTouchId) {
                        fireTouchId = null;
                        isShooting = false;
                        isADS = false;
                        camera.fov = cfg.fov;
                        camera.updateProjectionMatrix();
                        document.getElementById('sniper-scope').style.display = 'none';
                    }
                }
            });
            document.getElementById('btn-jump').onpointerdown = () => { if (!isPaused && jumps < 2) { vY = 0.8; jumps++; } };
            document.getElementById('btn-ads').onpointerdown = () => { if (!isPaused) { isADS = true; camera.fov = currentWeapon === 'SNIPER' ? 12 : 30; camera.updateProjectionMatrix(); if (currentWeapon === 'SNIPER') document.getElementById('sniper-scope').style.display = 'block'; } };
            document.getElementById('btn-ads').onpointerup = () => { isADS = false; camera.fov = cfg.fov; camera.updateProjectionMatrix(); document.getElementById('sniper-scope').style.display = 'none'; };
            document.getElementById('btn-settings').onclick = togglePauseMenu;
            document.getElementById('btn-eye').onclick = () => isFPS = !isFPS;

            document.getElementById('btn-nade').onpointerdown = () => {
                if (!isPlaying || isPaused) return;
                const g = new THREE.Mesh(new THREE.SphereGeometry(0.6, 12, 12), new THREE.MeshStandardMaterial({ color: grenadeType === 'explosive' ? 0x222222 : 0xeeeeee }));
                g.position.copy(playerGroup.position).add(new THREE.Vector3(0, 3.0, 0));
                ray.setFromCamera({ x: 0, y: 0 }, camera);
                const dir = ray.ray.direction.clone().normalize();
                const force = cameraPitch < -0.2 ? 1.2 : 3.8;

                // Usar tempo real em vez de frames
                g.userData = { vel: dir.multiplyScalar(force), life: GRENADE_LIFE_TIME, type: grenadeType, hasStopped: false };
                scene.add(g); grenades.push(g);
            };

            document.getElementById('btn-run').onclick = (e) => { isRunning = !isRunning; e.target.classList.toggle('active', isRunning); };
            document.getElementById('btn-swap-nade').onclick = (e) => { grenadeType = (grenadeType === 'explosive' ? 'smoke' : 'explosive'); e.target.innerHTML = `BOMBA<br>(${grenadeType === 'explosive' ? 'EXPL' : 'FUMA'})`; };
            document.getElementById('btn-switch-weapon').onclick = (e) => { currentWeapon = currentWeapon === 'AR' ? 'SNIPER' : 'AR'; e.target.innerHTML = `ARMA<br>(${currentWeapon === 'AR' ? 'FUZIL' : 'SNIPER'})`; };

            // NOVO: Configurar inputs do PC
            setupInputs();
        }

        function checkPathObstructedBySmoke(from, to) {
            for (let ef of effects) {
                if (ef.type === 'smoke') {
                    const smokePos = ef.m.position;
                    const distToLine = new THREE.Line3(from, to).closestPointToPoint(smokePos, true, new THREE.Vector3()).distanceTo(smokePos);
                    if (distToLine < (ef.m.scale.x * 6.0)) return true;
                }
            }
            return false;
        }

        function spawnBullet(owner, from, target, ownerId, accuracyBonus = 0) {
            if (checkPathObstructedBySmoke(from, target)) return;
            const dir = target.clone().sub(from).normalize();
            if (owner === 'bot') {
                const spread = Math.max(0, 0.05 - accuracyBonus);
                dir.x += (Math.random() - 0.5) * spread; dir.y += (Math.random() - 0.5) * spread; dir.z += (Math.random() - 0.5) * spread;
                dir.normalize();
            }
            const checkOrigin = new THREE.Raycaster(from, dir, 0, 2.5);
            const originHits = checkOrigin.intersectObjects(obstacles);
            if (originHits.length > 0 && originHits[0].object.userData.isWall) return;
            const startPos = from.clone().add(dir.clone().multiplyScalar(2.2));
            const b = new THREE.Mesh(bulletGeo, bulletMatYellow);
            b.position.copy(startPos);
            const speed = (owner === 'player' && currentWeapon === 'SNIPER') ? 14.0 : 9.5;
            b.userData = { vel: dir.multiplyScalar(speed), life: 250, owner, ownerId, prevPos: startPos.clone() };
            bullets.push(b); scene.add(b);
            if (owner === 'player') playSfx(currentWeapon === 'SNIPER' ? 'sniper' : 'shoot');
        }

        function startZoneTimer() { zoneActive = true; }

        function animate() {
            requestAnimationFrame(animate);
            if (!isPlaying || isPaused) return;

            // Calcular delta time (limitado para evitar grandes saltos)
            deltaTime = Math.min(clock.getDelta(), 0.1);
            const time = clock.getElapsedTime();
            charModel.rotation.y = THREE.MathUtils.lerp(charModel.rotation.y, cameraYaw, 0.3);

            document.getElementById('count-alive').innerText = bots.length + (health > 0 ? 1 : 0);
            document.getElementById('count-dead').innerText = (initialBotCount + 1) - (bots.length + (health > 0 ? 1 : 0));
            document.getElementById('count-kills').innerText = playerKills;

            let inputX = moveVec.x; let inputY = moveVec.y;
            if (keys['KeyW']) inputY = 1; if (keys['KeyS']) inputY = -1;
            if (keys['KeyA']) inputX = -1; if (keys['KeyD']) inputX = 1;

            // Aplicar delta time ao movimento
            const baseSpeed = isRunning ? PLAYER_SPEED_RUN : PLAYER_SPEED_WALK;
            const speed = baseSpeed * (isADS ? 0.4 : 1) * deltaTime;

            if (Math.hypot(inputX, inputY) > 0.1) {
                const moveAngle = Math.atan2(-inputX, inputY);
                const moveDir = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw + moveAngle);
                const nextX = playerGroup.position.clone().add(new THREE.Vector3(moveDir.x, 0, 0).multiplyScalar(speed));
                const nextZ = playerGroup.position.clone().add(new THREE.Vector3(0, 0, moveDir.z).multiplyScalar(speed));
                const pBoxX = new THREE.Box3().setFromCenterAndSize(nextX.clone().add(new THREE.Vector3(0, 2.5, 0)), new THREE.Vector3(0.4, 3.4, 0.4));
                const pBoxZ = new THREE.Box3().setFromCenterAndSize(nextZ.clone().add(new THREE.Vector3(0, 2.5, 0)), new THREE.Vector3(0.4, 3.4, 0.4));
                let hitX = false, hitZ = false;
                for (let i = 0; i < obstacleBoxes.length; i++) {
                    const box = obstacleBoxes[i];
                    if (box.userData?.isRamp) continue;
                    if (!hitX && pBoxX.intersectsBox(box)) hitX = true;
                    if (!hitZ && pBoxZ.intersectsBox(box)) hitZ = true;
                }
                if (!hitX) playerGroup.position.x = nextX.x;
                if (!hitZ) playerGroup.position.z = nextZ.z;
                charModel.userData.limbs.lLeg.rotation.x = Math.sin(time * 20) * 0.6; charModel.userData.limbs.rLeg.rotation.x = -Math.sin(time * 20) * 0.6;
            }

            for (let i = medkits.length - 1; i >= 0; i--) {
                const mk = medkits[i]; const worldPos = new THREE.Vector3(); mk.getWorldPosition(worldPos);
                if (playerGroup.position.distanceTo(worldPos) < 6) { health = Math.min(100, health + 40); scene.remove(mk); medkits.splice(i, 1); playSfx('hit'); continue; }
                for (let bot of bots) { if (bot.position.distanceTo(worldPos) < 6 && bot.userData.hp < bot.userData.maxHP) { bot.userData.hp = Math.min(bot.userData.maxHP, bot.userData.hp + 40); scene.remove(mk); medkits.splice(i, 1); playSfx('hit'); break; } }
            }

            playerGroup.position.y += vY * deltaTime * 60; // Manter compatibilidade com velocidade anterior
            const rayFloor = new THREE.Raycaster(playerGroup.position.clone().add(new THREE.Vector3(0, 8.0, 0)), new THREE.Vector3(0, -1, 0));
            const floorHits = rayFloor.intersectObjects(obstacles);
            let floorY = 0; if (floorHits.length > 0) floorY = floorHits[0].point.y;
            if (playerGroup.position.y > floorY + 0.15) vY -= GRAVITY * deltaTime; else { playerGroup.position.y = floorY; vY = 0; jumps = 0; }

            if (gasPauseTimer > 0) gasPauseTimer -= deltaTime;
            if (zoneActive && zoneRadius > 10) {
                if (gasPauseTimer <= 0) {
                    if ((gasPauseCount === 0 && zoneRadius <= 350) || (gasPauseCount === 1 && zoneRadius <= 150)) {
                        gasPauseCount++; gasPauseTimer = 30;
                    } else {
                        zoneRadius -= ZONE_SHRINK_RATE * deltaTime; zoneMesh.scale.set(zoneRadius, 1, zoneRadius);
                    }
                }
                if (Math.hypot(playerGroup.position.x, playerGroup.position.z) > zoneRadius) { health -= ZONE_DAMAGE_RATE * deltaTime; lastDamageTime = time; }
                const timerEl = document.getElementById('timer-display');
                if (gasPauseTimer > 0) timerEl.innerText = `PR√ìX. ZONA EM: ${Math.ceil(gasPauseTimer)}s`;
                else timerEl.innerText = `ZONA EM MOVIMENTO`;
            }
            if (time - lastDamageTime > 6 && armor < 100) armor = Math.min(100, armor + ARMOR_REGEN_RATE * deltaTime);
            document.getElementById('hp-bar').style.width = health + '%'; document.getElementById('armor-bar').style.width = armor + '%';

            for (let i = grenades.length - 1; i >= 0; i--) {
                const g = grenades[i];
                if (!g.userData.hasStopped) {
                    g.position.add(g.userData.vel.clone().multiplyScalar(deltaTime * 60)); // Manter compatibilidade
                    g.userData.vel.y -= GRAVITY * deltaTime * 1.5; // Gravidade da granada um pouco mais forte
                    const gRay = new THREE.Raycaster(g.position, g.userData.vel.clone().normalize(), 0, g.userData.vel.length() + 0.5);
                    const gHits = gRay.intersectObjects(obstacles);
                    if (gHits.length > 0 || g.position.y < 0.25) {
                        g.userData.hasStopped = true;
                        g.userData.vel.set(0, 0, 0);
                        if (g.position.y < 0.25) g.position.y = 0.25;
                    }
                }
                g.userData.life -= deltaTime; // Agora √© baseado em tempo real
                if (g.userData.life <= 0) {
                    if (g.userData.type === 'explosive') {
                        playSfx('exp');
                        for (let k = 0; k < 15; k++) {
                            const p = new THREE.Mesh(new THREE.SphereGeometry(1.2, 8, 8), new THREE.MeshBasicMaterial({ color: 0xff4400, transparent: true, opacity: 0.9 }));
                            p.position.copy(g.position).add(new THREE.Vector3((Math.random() - 0.5) * 5, Math.random() * 3, (Math.random() - 0.5) * 5));
                            scene.add(p); effects.push({ m: p, l: 45, type: 'explosion' });
                        }
                        bots.forEach(b => { if (b.position.distanceTo(g.position) < 30) b.userData.hp -= 200; });
                    } else {
                        for (let j = 0; j < 35; j++) {
                            const smk = new THREE.Mesh(new THREE.SphereGeometry(12, 12, 12), new THREE.MeshStandardMaterial({ color: 0x999999, transparent: true, opacity: 0.95 }));
                            smk.position.copy(g.position).add(new THREE.Vector3((Math.random() - 0.5) * 20, Math.random() * 10, (Math.random() - 0.5) * 20));
                            scene.add(smk); effects.push({ m: smk, l: 600, type: 'smoke' });
                        }
                    }
                    scene.remove(g); grenades.splice(i, 1);
                }
            }

            effects.forEach((ef, ei) => {
                if (ef.type === 'lighthouse') { ef.m.userData.update(time); }
                if (ef.type === 'explosion') { ef.m.scale.multiplyScalar(1.08); ef.m.material.opacity *= 0.9; }
                if (ef.type === 'smoke') { ef.m.scale.multiplyScalar(1.002); ef.m.material.opacity *= 0.998; }
                if (ef.l !== undefined && --ef.l <= 0) { scene.remove(ef.m); effects.splice(ei, 1); }
            });

            // MELHORIA NA MIRA: Posi√ß√£o de ADS agora √© a mesma de Hip Fire (Over the shoulder) para evitar obstru√ß√£o pela cabe√ßa
            if (isFPS || (isADS && currentWeapon === 'SNIPER')) {
                charModel.visible = false;
                camera.position.copy(playerGroup.position).add(new THREE.Vector3(0, 3.2, 0));
                camera.rotation.set(cameraPitch, cameraYaw, 0, 'YXZ');
            }
            else {
                charModel.visible = true;
                const dist = isADS ? 10.0 : 16.0;
                const offsetDist = 3.0; // Agora o offset lateral √© constante para n√£o tampar a vis√£o
                const rightDir = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYaw);
                const camPos = new THREE.Vector3(Math.sin(cameraYaw) * dist, Math.max(1.0, 5.8 - cameraPitch * 12), Math.cos(cameraYaw) * dist).add(rightDir.multiplyScalar(offsetDist));
                camera.position.copy(playerGroup.position).add(camPos);
                camera.lookAt(playerGroup.position.clone().add(new THREE.Vector3(0, 3.2, 0)).add(rightDir.multiplyScalar(offsetDist)));
            }

            ray.setFromCamera({ x: 0, y: 0 }, camera);
            const hitWorld = ray.intersectObjects(obstacles);
            const target = hitWorld.length > 0 ? hitWorld[0].point : ray.ray.at(500, new THREE.Vector3());
            charModel.userData.limbs.weapon.lookAt(target);

            if (isShooting) {
                fireFocusTimer += deltaTime;
                const focusThreshold = currentWeapon === 'SNIPER' ? 0.4 : 0.25;

                if (fireFocusTimer > focusThreshold) {
                    if (time - lastShot > (currentWeapon === 'SNIPER' ? 1.4 : 0.14)) {
                        spawnBullet('player', camera.position.clone(), target, 'player');
                        lastShot = time;
                    }
                }
            }

            for (let bi = bots.length - 1; bi >= 0; bi--) {
                const bot = bots[bi]; bot.position.y += bot.userData.vY * deltaTime * 60;
                const bRayFloor = new THREE.Raycaster(bot.position.clone().add(new THREE.Vector3(0, 4.0, 0)), new THREE.Vector3(0, -1, 0));
                const bFloorHits = bRayFloor.intersectObjects(obstacles); const bFloorY = bFloorHits.length > 0 ? bFloorHits[0].point.y : 0;
                if (bot.position.y > bFloorY) bot.userData.vY -= BOT_GRAVITY * deltaTime; else { bot.position.y = bFloorY; bot.userData.vY = 0; }

                bot.userData.jumpTimer -= deltaTime;
                if (bot.userData.jumpTimer <= 0 && bot.position.y <= bFloorY + 0.1) {
                    bot.userData.vY = 0.6;
                    bot.userData.jumpTimer = 2 + Math.random() * 3;
                }

                const distCenter = Math.hypot(bot.position.x, bot.position.z); const distPlayer = bot.position.distanceTo(playerGroup.position);

                if (distCenter > zoneRadius - 10) {
                    const moveSafe = new THREE.Vector3(0, 0, 0).sub(bot.position).normalize();
                    bot.position.add(moveSafe.multiplyScalar(BOT_SPEED * deltaTime * 0.5)); bot.lookAt(0, bot.position.y, 0);
                } else {
                    let separation = new THREE.Vector3(); for (let other of bots) { if (other === bot) continue; if (bot.position.distanceTo(other.position) < 8.0) separation.add(bot.position.clone().sub(other.position).normalize().multiplyScalar(0.5)); }
                    if (distPlayer < 12.0) separation.add(bot.position.clone().sub(playerGroup.position).normalize().multiplyScalar(0.6));

                    const isUnderFire = bot.userData.hp < bot.userData.maxHP && distPlayer > 50;

                    if ((distPlayer < 40 || bot.userData.isAggressive) && !isUnderFire) {
                        bot.userData.isAggressive = true;
                        if (bot.userData.currentHouse) {
                            bot.userData.currentHouse.botsInside--;
                            bot.userData.currentHouse = null;
                        }
                        const movePlayer = playerGroup.position.clone().sub(bot.position).normalize();
                        const sideDir = new THREE.Vector3(-movePlayer.z, 0, movePlayer.x).multiplyScalar(Math.sin(time * 12) * 0.8);
                        bot.position.add(movePlayer.multiplyScalar(BOT_SPEED * deltaTime * 0.4)).add(sideDir.multiplyScalar(deltaTime * 60)).add(separation.multiplyScalar(deltaTime * 60));
                        bot.lookAt(playerGroup.position.x, bot.position.y, playerGroup.position.z);
                    } else {
                        if (!bot.userData.currentHouse || isUnderFire) {
                            let targetDest = null; let minDestDist = Infinity;

                            houseData.forEach(h => {
                                if (h.botsInside < 2) {
                                    const d = bot.position.distanceTo(h.position);
                                    if (d < minDestDist) { minDestDist = d; targetDest = h; }
                                }
                            });

                            if (!targetDest) {
                                obstacles.forEach(o => {
                                    if (o.parent?.userData?.isTree) {
                                        const d = bot.position.distanceTo(o.position);
                                        if (d < minDestDist) { minDestDist = d; targetDest = { position: o.position, isTree: true }; }
                                    }
                                });
                            }

                            if (targetDest) {
                                const destPos = targetDest.position;
                                const moveCenter = destPos.clone().sub(bot.position).normalize();
                                const zigzag = new THREE.Vector3(-moveCenter.z, 0, moveCenter.x).multiplyScalar(Math.sin(time * 10) * 0.5);
                                bot.position.add(moveCenter.multiplyScalar(BOT_SPEED * deltaTime * 0.35)).add(zigzag.multiplyScalar(deltaTime * 60)).add(separation.multiplyScalar(deltaTime * 60));
                                bot.lookAt(destPos.x, bot.position.y, destPos.z);

                                if (minDestDist < 10) {
                                    if (!targetDest.isTree) {
                                        bot.userData.currentHouse = targetDest;
                                        targetDest.botsInside++;
                                        bot.userData.isAggressive = false;
                                    }
                                }
                            }
                        } else {
                            bot.lookAt(playerGroup.position.x, bot.position.y, playerGroup.position.z);
                            if (separation.length() > 0.1) bot.position.add(separation);
                        }
                    }

                    if ((bot.userData.currentHouse && distPlayer < 100) || bot.userData.isAggressive) {
                        const bEye = bot.position.clone().add(new THREE.Vector3(0, 3.2, 0));
                        const tHead = playerGroup.position.clone().add(new THREE.Vector3(0, 2.5, 0));
                        if (!checkPathObstructedBySmoke(bEye, tHead)) {
                            const bRay = new THREE.Raycaster(bEye, tHead.clone().sub(bEye).normalize());
                            const obs = bRay.intersectObjects(obstacles);
                            const wallHit = obs.find(hit => hit.distance < distPlayer && hit.object.userData.isWall);
                            if (!wallHit) {
                                bot.userData.reactionTimer += deltaTime;
                                if (bot.userData.reactionTimer > 0.3) {
                                    if (time - bot.userData.lastShot > (4.4 - cfg.diff)) { spawnBullet('bot', bEye, tHead, bot.userData.id, bot.userData.accuracyCharge); bot.userData.lastShot = time; }
                                }
                            }
                        }
                    }
                }
                if (bot.userData.hp <= 0) {
                    if (bot.userData.currentHouse) bot.userData.currentHouse.botsInside--;
                    addKillLog(`ELIMINADO: ${bot.userData.name}`);
                    playerKills++; scene.remove(bot); bots.splice(bi, 1); continue;
                }
                updateNPCHealthBar(bot.userData.hBar, (bot.userData.hp / bot.userData.maxHP) * 100);
            }

            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; const prevPos = b.position.clone(); b.position.add(b.userData.vel);
                const bRay = new THREE.Raycaster(prevPos, b.userData.vel.clone().normalize(), 0, b.userData.vel.length() + 0.5);
                const obsHits = bRay.intersectObjects(obstacles);
                const wallHit = obsHits.find(h => h.object.userData.isWall);
                if (wallHit) { scene.remove(b); bullets.splice(i, 1); continue; }
                let hitted = false;
                for (let bot of bots) {
                    if (b.userData.ownerId === bot.userData.id) continue;
                    const botBox = new THREE.Box3().setFromCenterAndSize(bot.position.clone().add(new THREE.Vector3(0, 2.4, 0)), new THREE.Vector3(3.0, 4.8, 3.0));
                    if (bRay.ray.intersectsBox(botBox)) {
                        const distToBot = b.position.distanceTo(bot.position);
                        const wallCheck = new THREE.Raycaster(prevPos, b.userData.vel.clone().normalize(), 0, distToBot);
                        const blockingWalls = wallCheck.intersectObjects(obstacles).filter(h => h.object.userData.isWall);
                        if (blockingWalls.length === 0) {
                            bot.userData.hp -= (b.userData.owner === 'player' && currentWeapon === 'SNIPER' ? 400 : 50);
                            if (b.userData.owner === 'player') triggerHitmarker();
                            scene.remove(b); bullets.splice(i, 1); hitted = true; break;
                        }
                    }
                }
                if (hitted) continue;
                const pBox = new THREE.Box3().setFromCenterAndSize(playerGroup.position.clone().add(new THREE.Vector3(0, 2.4, 0)), new THREE.Vector3(3.0, 4.8, 3.0));
                if (b.userData.owner !== 'player' && bRay.ray.intersectsBox(pBox)) {
                    const distToPlayer = b.position.distanceTo(playerGroup.position);
                    const wallCheck = new THREE.Raycaster(prevPos, b.userData.vel.clone().normalize(), 0, distToPlayer);
                    const blockingWalls = wallCheck.intersectObjects(obstacles).filter(h => h.object.userData.isWall);
                    if (blockingWalls.length === 0) {
                        const dmg = 6.0; if (armor > 0) armor -= dmg * 1.5; else health -= dmg; lastDamageTime = time; scene.remove(b); bullets.splice(i, 1); continue;
                    }
                }
                b.userData.prevPos.copy(b.position); if (--b.userData.life <= 0) { scene.remove(b); bullets.splice(i, 1); }
            }
            if (health <= 0 && isPlaying) showMsg("ELIMINADO", "Voc√™ n√£o resistiu.");
            if (bots.length === 0 && isPlaying) showMsg("BOOYAH!", "O soberano de Cana√£!");
            updateMinimap(); renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); });

        setupInputs();

        // ============================================
        // INPUTS E CONTROLES (NOVO)
        // ============================================
        function setupInputs() {
            // Mouse (C√¢mera e Tiro)
            document.addEventListener('mousedown', (e) => {
                if (!isPlaying || isPaused) return;

                // Travar ponteiro ao clicar
                if (document.pointerLockElement !== document.body) {
                    document.body.requestPointerLock();
                    return;
                }

                if (e.button === 0) { // Bot√£o esquerdo
                    isShooting = true;
                    // Se for mobile/touch simulation no PC
                    if (currentWeapon === 'AR') fireFocusTimer = 0;
                } else if (e.button === 2) { // Bot√£o direito
                    isADS = true;
                    updateADS();
                }
            });

            document.addEventListener('mouseup', (e) => {
                if (e.button === 0) isShooting = false;
                if (e.button === 2) {
                    isADS = false;
                    updateADS();
                }
            });

            document.addEventListener('mousemove', (e) => {
                if (document.pointerLockElement === document.body && !isPaused && isPlaying) {
                    const sens = cfg.sens || 0.002;
                    cameraYaw -= e.movementX * sens;
                    cameraPitch -= e.movementY * sens;
                    // Limitar pitch (olhar pra cima/baixo)
                    cameraPitch = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraPitch));
                }
            });

            // Teclado (Movimento e A√ß√µes)
            document.addEventListener('keydown', (e) => {
                if (!isPlaying) return;

                // ESC - Pause/Menu
                if (e.code === 'Escape') {
                    togglePauseMenu();
                    if (isPaused) {
                        document.exitPointerLock();
                    } else {
                        document.body.requestPointerLock();
                    }
                    return;
                }

                if (isPaused) return;

                keys[e.code] = true;

                // A√ß√µes instant√¢neas
                if (e.code === 'KeyR') reloadWeapon();
                if (e.code === 'Space' && jumps > 0) { vY = 0.4; jumps--; }
                if (e.code === 'Digit1') switchWeapon('AR');
                if (e.code === 'Digit2') switchWeapon('SNIPER');
                if (e.code === 'KeyF') {
                    // Interagir / Trocar granada
                    grenadeType = grenadeType === 'explosive' ? 'smoke' : 'explosive';
                    // Atualizar UI se existir
                }
                if (e.code === 'ShiftLeft') isRunning = true;
            });

            document.addEventListener('keyup', (e) => {
                keys[e.code] = false;
                if (e.code === 'ShiftLeft') isRunning = false;
            });
        }
    </script>
</body>

</html>